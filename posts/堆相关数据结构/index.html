<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>堆概述及其相关数据结构 - Ghostasky&#39;s Blog</title><meta name="author" content="Ghostasky">
<meta name="author-link" content="">
<meta name="description" content="[TOC] 堆利用 目前堆的实现有很多种，具体如下： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris 接下来主要以glibc中堆的实现为主进行介绍。 堆概述 内存分配后的系统调用 在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数" /><meta name="keywords" content='' />
  <meta itemprop="name" content="堆概述及其相关数据结构">
  <meta itemprop="description" content="[TOC] 堆利用 目前堆的实现有很多种，具体如下： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris 接下来主要以glibc中堆的实现为主进行介绍。 堆概述 内存分配后的系统调用 在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数">
  <meta itemprop="datePublished" content="2021-03-03T22:18:17+00:00">
  <meta itemprop="dateModified" content="2021-03-03T22:18:17+00:00">
  <meta itemprop="wordCount" content="5944">
  <meta itemprop="keywords" content="Technology"><meta property="og:url" content="http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
  <meta property="og:site_name" content="Ghostasky&#39;s Blog">
  <meta property="og:title" content="堆概述及其相关数据结构">
  <meta property="og:description" content="[TOC] 堆利用 目前堆的实现有很多种，具体如下： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris 接下来主要以glibc中堆的实现为主进行介绍。 堆概述 内存分配后的系统调用 在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-03-03T22:18:17+00:00">
    <meta property="article:modified_time" content="2021-03-03T22:18:17+00:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="堆概述及其相关数据结构">
  <meta name="twitter:description" content="[TOC] 堆利用 目前堆的实现有很多种，具体如下： dlmalloc – General purpose allocator ptmalloc2 – glibc jemalloc – FreeBSD and Firefox tcmalloc – Google libumem – Solaris 接下来主要以glibc中堆的实现为主进行介绍。 堆概述 内存分配后的系统调用 在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><link rel="prev" href="http://ghostasky.github.io/posts/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/" /><link rel="next" href="http://ghostasky.github.io/posts/%E7%AE%80%E5%8D%95%E5%A0%86%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "堆概述及其相关数据结构",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/ghostasky.github.io\/posts\/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/"
    },"genre": "posts","keywords": "","wordcount":  5944 ,
    "url": "http:\/\/ghostasky.github.io\/posts\/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\/","datePublished": "2021-03-03T22:18:17+00:00","dateModified": "2021-03-03T22:18:17+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "Ghostasky"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="auto" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="Ghostasky&#39;s Blog" data-title="Ghostasky&#39;s Blog" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="typeit"><template> Ghostasky&#39;s Blog</template></span></a><span class="header-subtitle">未语之痕</span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              >关于</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="Ghostasky&#39;s Blog" data-title="Ghostasky&#39;s Blog" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="typeit"><template> Ghostasky&#39;s Blog</template></span></a><span class="header-subtitle">未语之痕</span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                >文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                >关于</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>堆概述及其相关数据结构</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><img loading="lazy" src="/images/fixit.png" alt="Ghostasky" data-title="Ghostasky" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;Ghostasky</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/technology/" class="post-category" title="分类 - Technology"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Technology</a></span></div><div class="post-meta-line"><span title="发布于 2021-03-03 22:18:17"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2021-03-03">2021-03-03</time></span>&nbsp;<span title="5944 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 6000 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 12 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#堆利用">堆利用</a></li>
    <li><a href="#堆概述">堆概述</a>
      <ul>
        <li><a href="#内存分配后的系统调用">内存分配后的系统调用</a></li>
      </ul>
    </li>
    <li><a href="#堆相关的数据结构">堆相关的数据结构</a>
      <ul>
        <li><a href="#微观结构">微观结构</a></li>
        <li><a href="#宏观结构">宏观结构</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>[TOC]</p>
<h2 id="堆利用" class="heading-element"><span>堆利用</span>
  <a href="#%e5%a0%86%e5%88%a9%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>目前堆的实现有很多种，具体如下：</p>
<blockquote>
<p>dlmalloc  – General purpose allocator</p>
<p>ptmalloc2 – glibc</p>
<p>jemalloc  – FreeBSD and Firefox</p>
<p>tcmalloc  – Google</p>
<p>libumem   – Solaris</p>
</blockquote>
<p>接下来主要以glibc中堆的实现为主进行介绍。</p>
<h2 id="堆概述" class="heading-element"><span>堆概述</span>
  <a href="#%e5%a0%86%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="内存分配后的系统调用" class="heading-element"><span>内存分配后的系统调用</span>
  <a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%90%8e%e7%9a%84%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>在我们动态申请和释放内存时，无论是malloc还是free函数，都不是真正与系统交互的函数</p>
<p>这些函数的背后系统调用主要是(s)brk和mmap、munmap函数</p>
<p>如下图：</p>
<p><img loading="lazy" src="1614781158558.png" alt="1614781158558.png" srcset="1614781158558.png?size=small, 1614781158558.png?size=medium 1.5x, 1614781158558.png?size=large 2x" data-title="1614781158558.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<h4 id="sbrk" class="heading-element"><span>(s)brk</span>
  <a href="#sbrk" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>对于堆来说，操作系统提供了brk函数，glibc库提供了sbrk函数，我们也可通过增加brk的大小来向操作系统申请内存。</p>
<p>在一开始，堆的起始位置(start_brk)和堆的当前结尾地址(brk)指向同一地址。根据是否开启ASLR，指的位置不同</p>
<ul>
<li>未开启ASLR：start_brk和brk指向data/bss段的结尾</li>
<li>开启ASLR：start_brk和brk会指向data/bss段结尾后的随机偏移的位置</li>
</ul>
<p>举个小例子：(来自ctf-wiki)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* sbrk and brk example */</span>
</span></span><span class="line"><span class="cl"><span class="cp">##include &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;unistd.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;sys/types.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="o">*</span><span class="n">curr_brk</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp_brk</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Welcome to sbrk example:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* sbrk(0) gives current program break location */</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp_brk</span> <span class="o">=</span> <span class="n">curr_brk</span> <span class="o">=</span> <span class="nf">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Program Break Location1:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* brk(addr) increments/decrements program break location */</span>
</span></span><span class="line"><span class="cl">        <span class="nf">brk</span><span class="p">(</span><span class="n">curr_brk</span><span class="o">+</span><span class="mi">4096</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">curr_brk</span> <span class="o">=</span> <span class="nf">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Program break Location2:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nf">brk</span><span class="p">(</span><span class="n">tmp_brk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">curr_brk</span> <span class="o">=</span> <span class="nf">sbrk</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Program Break Location3:%p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">curr_brk</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>执行后3次分别如下：</p>
<pre tabindex="0"><code>yutao@pwnbaby:~/Desktop$ ./a.out 
Welcome to sbrk example:2552
Program Break Location1:0x56c4d000

Program break Location2:0x56c4e000

Program Break Location3:0x56c4d000</code></pre><pre tabindex="0"><code>yutao@pwnbaby:~/Desktop$ cat /proc/2552/maps
...
56c2b000-56c4d000 rw-p 00000000 00:00 0                                  [heap]
...

yutao@pwnbaby:~/Desktop$ cat /proc/2552/maps
...
56c2b000-56c4e000 rw-p 00000000 00:00 0                                  [heap]
...

yutao@pwnbaby:~/Desktop$ cat /proc/2552/maps
...
56c2b000-56c4d000 rw-p 00000000 00:00 0                                  [heap]
...</code></pre><h4 id="mmap" class="heading-element"><span>mmap</span>
  <a href="#mmap" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>malloc会使用mmap来创建独立的匿名映射段。匿名映射的主要目的是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Private anonymous mapping example using mmap syscall */</span>
</span></span><span class="line"><span class="cl"><span class="cp">##include &lt;stdio.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;sys/mman.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;sys/types.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;sys/stat.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;fcntl.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;unistd.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp">##include &lt;stdlib.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="k">static</span> <span class="kr">inline</span> <span class="nf">errExit</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s failed. Exiting the process</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Welcome to private anonymous mapping example::PID:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Before mmap</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">addr</span> <span class="o">=</span> <span class="nf">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">132</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">errExit</span><span class="p">(</span><span class="s">&#34;mmap&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;After mmap</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Unmap mapped region. */</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="nf">munmap</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">132</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="nf">errExit</span><span class="p">(</span><span class="s">&#34;munmap&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;After munmap</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">getchar</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>在执行mmap前：</p>
<pre tabindex="0"><code>yutao@pwnbaby:~$ cat /proc/2412/maps
5656c000-5656d000 r-xp 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656d000-5656e000 r--p 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656e000-5656f000 rw-p 00001000 08:01 956125                             /home/yutao/Desktop/a.out
56fdf000-57001000 rw-p 00000000 00:00 0                                  [heap]
f7d90000-f7f65000 r-xp 00000000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f65000-f7f66000 ---p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f66000-f7f68000 r--p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f68000-f7f69000 rw-p 001d7000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f69000-f7f6c000 rw-p 00000000 00:00 0 
f7f82000-f7f84000 rw-p 00000000 00:00 0 
f7f84000-f7f87000 r--p 00000000 00:00 0                                  [vvar]
f7f87000-f7f88000 r-xp 00000000 00:00 0                                  [vdso]
f7f88000-f7fae000 r-xp 00000000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7fae000-f7faf000 r--p 00025000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7faf000-f7fb0000 rw-p 00026000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
ffab0000-ffad1000 rw-p 00000000 00:00 0                                  [stack]</code></pre><p>执行mmap后：</p>
<pre tabindex="0"><code>yutao@pwnbaby:~$ cat /proc/2412/maps
5656c000-5656d000 r-xp 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656d000-5656e000 r--p 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656e000-5656f000 rw-p 00001000 08:01 956125                             /home/yutao/Desktop/a.out
56fdf000-57001000 rw-p 00000000 00:00 0                                  [heap]
f7d6f000-f7d90000 rw-p 00000000 00:00 0 
f7d90000-f7f65000 r-xp 00000000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f65000-f7f66000 ---p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f66000-f7f68000 r--p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f68000-f7f69000 rw-p 001d7000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f69000-f7f6c000 rw-p 00000000 00:00 0 
f7f82000-f7f84000 rw-p 00000000 00:00 0 
f7f84000-f7f87000 r--p 00000000 00:00 0                                  [vvar]
f7f87000-f7f88000 r-xp 00000000 00:00 0                                  [vdso]
f7f88000-f7fae000 r-xp 00000000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7fae000-f7faf000 r--p 00025000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7faf000-f7fb0000 rw-p 00026000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
ffab0000-ffad1000 rw-p 00000000 00:00 0                                  [stack]</code></pre><p>munmap：</p>
<pre tabindex="0"><code>yutao@pwnbaby:~$ cat /proc/2412/maps
5656c000-5656d000 r-xp 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656d000-5656e000 r--p 00000000 08:01 956125                             /home/yutao/Desktop/a.out
5656e000-5656f000 rw-p 00001000 08:01 956125                             /home/yutao/Desktop/a.out
56fdf000-57001000 rw-p 00000000 00:00 0                                  [heap]
f7d90000-f7f65000 r-xp 00000000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f65000-f7f66000 ---p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f66000-f7f68000 r--p 001d5000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f68000-f7f69000 rw-p 001d7000 08:01 1195832                            /lib/i386-linux-gnu/libc-2.27.so
f7f69000-f7f6c000 rw-p 00000000 00:00 0 
f7f82000-f7f84000 rw-p 00000000 00:00 0 
f7f84000-f7f87000 r--p 00000000 00:00 0                                  [vvar]
f7f87000-f7f88000 r-xp 00000000 00:00 0                                  [vdso]
f7f88000-f7fae000 r-xp 00000000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7fae000-f7faf000 r--p 00025000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
f7faf000-f7fb0000 rw-p 00026000 08:01 1195828                            /lib/i386-linux-gnu/ld-2.27.so
ffab0000-ffad1000 rw-p 00000000 00:00 0                                  [stack]</code></pre><h2 id="堆相关的数据结构" class="heading-element"><span>堆相关的数据结构</span>
  <a href="#%e5%a0%86%e7%9b%b8%e5%85%b3%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>glibc内部有精心设计的数据结构来管理它：</p>
<ul>
<li>宏观结构：包含堆的宏观信息，可通过这些数据结构索引对的基本信息</li>
<li>微观结构：用于处理堆分配与回收中的内存块</li>
</ul>
<h3 id="微观结构" class="heading-element"><span>微观结构</span>
  <a href="#%e5%be%ae%e8%a7%82%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>这里先讲微观结构，堆的漏洞利用和这些相关</p>
<h4 id="malloc_chunk概述" class="heading-element"><span>malloc_chunk概述</span>
  <a href="#malloc_chunk%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>我们成malloc申请的内存为chunk。这些内存在ptmalloc内部用malloc_chunk结构体来表示，</p>
<p>当程序申请的chunk被free后，会被加入到响应的空闲管理列表中。</p>
<p>无论一个chunk有多大，无论处于malloc状态还是free状态，他们的结构都是一样的。</p>
<p>malloc_chunk结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  This struct declaration is misleading (but accurate and necessary).
</span></span></span><span class="line"><span class="cl"><span class="cm">  It declares a &#34;view&#34; into memory allowing access to necessary
</span></span></span><span class="line"><span class="cl"><span class="cm">  fields at known offsets from a given base. See explanation below.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>这里有INTERNAL_SIZE_T，SIZE_SZ，MALLOC_ALIGN_MASK的解释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">/</span> <span class="o">*</span> <span class="n">INTERNAL_SIZE_T是用于内部记录块大小的</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">   <span class="err">默认版本与</span><span class="n">size_t相同</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">   <span class="err">尽管不是绝对必要，但最好将其定义为无符号类型，即使</span><span class="n">size_t是有符号类型也是如此</span><span class="err">。这可以避免某些系统的人为大小限制。</span>
</span></span><span class="line"><span class="cl">   <span class="err">在</span><span class="mi">64</span><span class="err">位计算机上，通过将</span><span class="n">INTERNAL_SIZE_T定义为32位</span><span class="err">“</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="err">”，您可以减少</span><span class="n">malloc开销</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">   <span class="err">不能处理超过</span><span class="mi">2</span> <span class="o">^</span> <span class="mi">32</span><span class="err">的已分配空间的开销。如果可以接受此限制，除非您在要求</span><span class="mi">16</span><span class="err">字节对齐的平台上，否则建议您进行设置。在这种情况下，对齐要求最终抵消了减小</span><span class="n">size_t字大小的任何潜在优势</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">   <span class="err">实现者：谨防以下情况的可能组合：</span>
</span></span><span class="line"><span class="cl">     <span class="o">-</span><span class="n">INTERNAL_SIZE_T可能是有符号的或无符号的</span><span class="err">，可能是</span><span class="mi">32</span><span class="err">位或</span><span class="mi">64</span><span class="err">位，并且宽度可能与</span><span class="n">int相同或与long相同</span>
</span></span><span class="line"><span class="cl">     <span class="o">-</span><span class="n">size_t的宽度和签名可能与INTERNAL_SIZE_T不同</span>
</span></span><span class="line"><span class="cl">     <span class="o">-</span><span class="n">int和long可能是32或64位</span><span class="err">，并且可能是相同的宽度</span>
</span></span><span class="line"><span class="cl">   <span class="err">为了解决这个问题，</span><span class="n">INTERNAL_SIZE_T之间的大多数比较和差值计算都应将它们强制转换为无符号长整数</span><span class="err">，并意识到将无符号</span><span class="n">int强制转换为较宽长整数不会对符号进行扩展的事实</span><span class="err">。</span> <span class="err">（这也使检查负数变得很尴尬。）其中的某些强制转换在某些系统上会导致无害的编译器警告。</span> <span class="o">*</span> <span class="o">/</span>
</span></span><span class="line"><span class="cl"><span class="cp">##ifndef INTERNAL_SIZE_T
</span></span></span><span class="line"><span class="cl"><span class="cp">##define INTERNAL_SIZE_T size_t
</span></span></span><span class="line"><span class="cl"><span class="cp">##endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* The corresponding word size.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">##define SIZE_SZ (sizeof (INTERNAL_SIZE_T))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cm">/* The corresponding bit mask value.  */</span>
</span></span><span class="line"><span class="cl"><span class="cp">##define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span></span></code></pre></div><p>一般来说，size_t在64位中是64位无符号整数，32位中是32位无符号整数。</p>
<p>malloc_chunk的具体解释如下：</p>
<ul>
<li>prev_size：如果该chunk的 物理相邻的前一个chunk是空闲的话，那该处记录的是前一个chunk的大小(<strong>包含chunk头</strong>)。如果物理相邻的前一个chunk处于malloc状态，那么此处可以填写前一个chunk的数据。</li>
<li>size：该chunk的大小(prev_size+size+user data)，必须是2*SIZE_SZ的整数倍。如果申请的内存不是2*SIZE_SZ的整数倍，那么向上取整。32位中SIZE_SZ是4；64位中是8。该字段的 低3bit位对chunk大小没有影响，依次为：
<ul>
<li>NON_MAIN_ARENA(A)：记录当前chunk是否属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED(M)：记录当前chunk是否是由mmap分配的。</li>
<li>PREV_INUSE(P)：记录前一个chunk是否被分配。一般来说，堆中第一个被分配的内存块的该位都会被设为1，以便防止访问前面的非法内存；当该位是0时，可以通过prev_size字段来获取上一个chunk的大小和地址。也方便空闲chunk之间的合并。</li>
</ul>
</li>
<li>fd，dk：chunk处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下：
<ul>
<li>fd指向下一个(<strong>非物理相邻</strong>)空闲的chunk。</li>
<li>bk指向上一个(<strong>非物理相邻</strong>)空闲的chunk。</li>
<li>通过bk和fd可以将空闲的chunk加入到空闲的chunk链表进行统一管理</li>
</ul>
</li>
<li>fd_nextsize，bk_nextsize：只有chunk空闲时候才使用，<strong>用于较大的chunk(large chunk)</strong>。
<ul>
<li>fd_nextsize：指向前一个与当chunk大小不同的第一个空闲快，不含bin的头指针。</li>
<li>k_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</li>
</ul>
</li>
</ul>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p>
<pre tabindex="0"><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of chunk, in bytes                     |A|M|P|
  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             User data starts here...                          |
        .                                                               .
        .             (malloc_usable_size() bytes)                      .
next    .                                                               .
chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             (size of chunk, but used for application data)    |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|1|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>被free的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<pre tabindex="0"><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`head:&#39; |             Size of chunk, in bytes                     |A|0|P|
  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Forward pointer to next chunk in list             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Back pointer to previous chunk in list            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Unused space (may be 0 bytes long)                .
        .                                                               .
 next   .                                                               |
chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`foot:&#39; |             Size of chunk, in bytes                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录，</li>
<li>它后面的 chunk 会记录。</li>
</ol>
<p>一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<h4 id="bin" class="heading-element"><span>bin</span>
  <a href="#bin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><h5 id="概述" class="heading-element"><span>概述</span>
  <a href="#%e6%a6%82%e8%bf%b0" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>bin这个概念是与<strong>内存回收</strong>相关堆，也就是堆管理器会根据用户已经申请到堆内存空间大小进行释放，决定放入哪类bins当中去。</p>
<p>用户释放的chunk不会马上归还给系统，ptmalloc会统一管理heap和mmap映射区域中空闲的chunk。当用户再次malloc时，ptmalloc分配器会识图在空闲的chunk中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p><strong>ptmalloc将相似大小堆chunk用双向线标链接起来，这样的一个链表叫做一个bin</strong>。</p>
<p>ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin。</p>
<p>数组中<strong>bin 1为unsorted bin</strong>；<strong>bin 2到63为small bin</strong>；<strong>bin 64到126为large bin</strong></p>
<p>具体的实现中，ptmalloc采用分箱式的方法对空闲的chunk进行管理。</p>
<p>首先，他会根据空闲chunk的大小及使用状态将chunk初步分为4类：fast bins，small bins，large bins，unsorted bin。每一类中仍有更详细的划分。相似大小的chunk会使用双向链表链接起来。也就是说，在每一类bin的内部仍有多个互不相关的链表来保存不同大小的chunk.
<img loading="lazy" src="1614781245754.png" alt="1614781245754.png" srcset="1614781245754.png?size=small, 1614781245754.png?size=medium 1.5x, 1614781245754.png?size=large 2x" data-title="1614781245754.png" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">##define NBINS 128
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* Normal bins packed as described above */</span>
</span></span><span class="line"><span class="cl"><span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span></span></span></code></pre></div><p>一个bin相当于一个chunk链表，每个链表的头结点chunk作为bins数组，但由于这个头结点作为bin表头，prev_size与size字段是没有任何实际作用的，因此在存储头结点chunk的时候仅仅只需存储头结点chunk的fd和bk即可，而其中的prev_size与size字段被重用为另一个bin的头结点的fd和bk，这样可节省空间，并提高可用性。。因此<strong>我们仅仅只需要 mchunkptr 类型的指针数组就足够存储这些头节点</strong>，那 prev_size 与 size 字段到底是怎么重用的呢？这里我们以 32 位系统为例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">含义</th>
<th style="text-align:left">bin1 的 fd/bin2 的 prev_size</th>
<th style="text-align:left">bin1 的 bk/bin2 的 size</th>
<th style="text-align:left">bin2 的 fd/bin3 的 prev_size</th>
<th style="text-align:left">bin2 的 bk/bin3 的 size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bin 下标</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">2</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<p>可以看出除了第一个 bin（unsorted bin）外，后面的每个 bin 的表头 chunk 会重用前面的 bin 表头 chunk 的 fd 与 bk 字段，将其视为其自身的 prev_size 和 size 字段。这里也说明了一个问题，<strong>bin 的下标和我们所说的第几个 bin 并不是一致的。同时，bin 表头的 chunk 头节点 的 prev_size 与 size 字段不能随便修改，因为这两个字段是其它 bin 表头 chunk 的 fd 和 bk 字段。</strong></p>
<p>数组中的 bin 依次介绍如下：</p>
<ol>
<li>第1个为 unsorted bin，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk 先放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<h5 id="fast-bin" class="heading-element"><span>Fast Bin</span>
  <a href="#fast-bin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>fast bin所包含chunk的大小为16 Bytes, 24 Bytes, 32 Bytes, … , 80 Bytes。当分配一块较小的内存(mem&lt;=64 Bytes)时，<strong>会首先检查对应大小的fastbin中是否包含未被使用的chunk，如果存在则直接将其从fastbin中移除并返回；否则通过其他方式（剪切top chunk）得到一块符合大小要求的chunk并返回。</strong></p>
<p>描述：</p>
<ol>
<li>x86中，当用户释放堆堆块大小小于64B时使用fast bin进行管理，即chunk空间最大为80字节。</li>
<li>fast bin只用了fd，是单链表。</li>
<li>fast bin不会对P位进行操作，即它不会主动进行合并，只有在某些特定堆情况下，堆管理器才会对fast bin进行合并。</li>
<li>fast binY为管理fast bin的数组，每个成员分别管理不同大小的fast bin链表，且均指向了当前链表的尾结点，当尾结点被分配时，通过fd指针指向前一个节点。</li>
<li>当用户申请chunk的大小小于或等于<strong>MAX_FAST_SIZE</strong>时，优先从fast bin中查找相应的空闲块，且规则为LIFO。</li>
</ol>
<h5 id="small-bin" class="heading-element"><span>Small bin</span>
  <a href="#small-bin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：<code>chunk_size = 2 * SIZE_SZ *index</code>，具体如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">下标</th>
<th style="text-align:left">SIZE_SZ=4（32 位）</th>
<th style="text-align:left">SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">24</td>
<td style="text-align:left">48</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">40</td>
<td style="text-align:left">80</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">2*4*x</td>
<td style="text-align:left">2*8*x</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left">504</td>
<td style="text-align:left">1008</td>
</tr>
</tbody>
</table>
<p>small bins 中一共有 62 个循环双向链表，每个链表中存储的 chunk 大小都一致。</p>
<p>描述：</p>
<ol>
<li>small bin为双向链表，且使用FIFO,所以同一个链表中先被释放的 chunk 会先被分配出去。</li>
<li>当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中。</li>
</ol>
<h5 id="large-bin" class="heading-element"><span>Large bin</span>
  <a href="#large-bin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><p>large bins中一共包含63个bin，每个bin中的chunk的大小不一致，而是处于一定的区间范围没，此外，这63个bin被分为了6组，每个bin中的chunk大小之间的公差一致，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">组</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">公差</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">32</td>
<td style="text-align:left">64B</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
<td style="text-align:left">512B</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">8</td>
<td style="text-align:left">4096B</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32768B</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2</td>
<td style="text-align:left">262144B</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">1</td>
<td style="text-align:left">不限制</td>
</tr>
</tbody>
</table>
<p>这里以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)</p>
<h5 id="unsorted-bin" class="heading-element"><span>unsorted bin</span>
  <a href="#unsorted-bin" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h5><ol>
<li>unsorted bin可以视为空闲chunk回归其所属bin之前的缓冲区。</li>
<li>当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中</li>
<li>unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中</li>
</ol>
<h4 id="top-chunk" class="heading-element"><span>top chunk</span>
  <a href="#top-chunk" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>程序在第一次进行malloc时，heap会分为两部分，一部分给用户，另一部分就是top chunk。</p>
<p>top chunk是处于当前堆的物理地址的最高的chunk，这个chunk不属于任何一个bin，当所有的 bin 都无法满足用户请求的内存大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<h3 id="宏观结构" class="heading-element"><span>宏观结构</span>
  <a href="#%e5%ae%8f%e8%a7%82%e7%bb%93%e6%9e%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><h4 id="arena" class="heading-element"><span>arena</span>
  <a href="#arena" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h4><p>在之前介绍的例子中，无论是主线程还是新创建的线程，在第一次申请内存时，都会有独立的 arena。</p>
<p>但不是每个线程都有独立的arena，对于不同的系统，arena数量的约束如下：</p>
<pre tabindex="0"><code>For 32 bit systems:
     Number of arena = 2 * number of cores.
For 64 bit systems:
     Number of arena = 8 * number of cores.</code></pre></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2021-03-03 22:18:17">更新于 2021-03-03&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 X" data-sharer="twitter" data-url="http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title="堆概述及其相关数据结构" data-hashtags=""><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-hashtag="[PWN]"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://ghostasky.github.io/posts/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-title="堆概述及其相关数据结构"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/" class="post-nav-item" rel="prev" title="整数溢出"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>整数溢出</a>
      <a href="/posts/%E7%AE%80%E5%8D%95%E5%A0%86%E6%BA%A2%E5%87%BA%E4%BB%8B%E7%BB%8D/" class="post-nav-item" rel="next" title="简单堆溢出介绍">简单堆溢出介绍<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.126.2"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.8-RC"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="/">Ghostasky</a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">该网站在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"typeit":{"cursorChar":"|","cursorSpeed":1000,"duration":-1,"loop":false,"speed":100},"version":"v0.3.8-RC"};</script><script src="/js/theme.min.js" defer></script></body>
</html>
