<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>【译】AFL白皮书 - Ghostasky&#39;s Blog</title><meta name="author" content="">
<meta name="author-link" content="">
<meta name="description" content="" /><meta name="keywords" content='RE' /><meta itemprop="name" content="【译】AFL白皮书">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2023-05-16T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-05-16T00:00:00+00:00" />
<meta itemprop="wordCount" content="15479">
<meta itemprop="keywords" content="RE," /><meta property="og:title" content="【译】AFL白皮书" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/2023-5aflwritepaper/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-05-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="【译】AFL白皮书"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://localhost:1313/posts/2023-5aflwritepaper/" /><link rel="prev" href="http://localhost:1313/posts/2023-5antidebug/" /><link rel="next" href="http://localhost:1313/posts/2023-7-win-syscalljourney/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "【译】AFL白皮书",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/posts\/2023-5aflwritepaper\/"
    },"genre": "posts","keywords": "RE","wordcount":  15479 ,
    "url": "http:\/\/localhost:1313\/posts\/2023-5aflwritepaper\/","datePublished": "2023-05-16T00:00:00+00:00","dateModified": "2023-05-16T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "作者"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="Ghostasky&#39;s Blog" data-title="Ghostasky&#39;s Blog" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Ghostasky&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              >关于</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="/images/fixit.png" data-title="/images/fixit.png" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Ghostasky&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                >文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                >关于</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>【译】AFL白皮书</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Anonymous</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/technology/" class="post-category" title="分类 - Technology"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Technology</a></span></div><div class="post-meta-line"><span title="发布于 2023-05-16 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2023-05-16">2023-05-16</time></span>&nbsp;<span title="15479 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 15500 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 31 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#afl-fuzz-技术-白皮书">afl-fuzz 技术 白皮书</a></li>
    <li><a href="#0-设计说明design-statement">0. 设计说明(Design statement)</a></li>
    <li><a href="#1-覆盖率检测coverage-measurements">1. 覆盖率检测(Coverage measurements)</a></li>
    <li><a href="#2-新路径检测detecting-new-behaviors">2. 新路径检测(Detecting new behaviors)</a></li>
    <li><a href="#3-输入队列变异evolving-the-input-queue">3. 输入队列变异(Evolving the input queue)</a></li>
    <li><a href="#4-精简语料库culling-the-corpus">4. 精简语料库(Culling the corpus)</a></li>
    <li><a href="#5-修剪输入文件trimming-input-files">5. 修剪输入文件(Trimming input files)</a></li>
    <li><a href="#6-模糊测试策略fuzzing-strategies">6. 模糊测试策略(Fuzzing strategies)</a></li>
    <li><a href="#7-字典构建dictionaries">7. 字典构建(Dictionaries)</a></li>
    <li><a href="#8-崩溃去重de-duping-crashes">8. 崩溃去重(De-duping crashes)</a></li>
    <li><a href="#9-崩溃调查investigating-crashes">9. 崩溃调查(Investigating crashes)</a></li>
    <li><a href="#10-fork服务器the-fork-server">10. fork服务器(The fork server)</a></li>
    <li><a href="#11-并行处理parallelization">11. 并行处理(Parallelization)</a></li>
    <li><a href="#12-二进制插桩binary-only-instrumentation">12. 二进制插桩(Binary-only instrumentation)</a></li>
    <li><a href="#13-afl分析工具the-afl-analyze-tool">13. AFL分析工具(The afl-analyze tool)</a></li>
    <li><a href="#todo">TODO</a></li>
    <li><a href="#附-afl设计目标和动机的讨论historical-notes">附: AFL设计目标和动机的讨论(historical notes)</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>[toc]</p>
<p>AFL 翻译</p>
<h2 id="afl-fuzz-技术-白皮书" class="heading-element">
  <a href="#afl-fuzz-%e6%8a%80%e6%9c%af-%e7%99%bd%e7%9a%ae%e4%b9%a6" class="heading-mark"></a>afl-fuzz 技术 白皮书</h2><p>本文档快速概述了American Fuzzy Lop的核心内容。</p>
<p>请参阅README获取一般指导手册；有关AFL背后动机和设计目标的讨论，请参阅<a href="https://lcamtuf.coredump.cx/afl/historical_notes.txt"target="_blank" rel="external nofollow noopener noreferrer">historical_notes.txt</a>。</p>
<blockquote>
<p>historical_notes:
这篇文档主要谈论了AFL（American Fuzzy Lop）的设计理念和灵感来源，以及与其他fuzzing工具的比较。作者认为，AFL的设计目标是解决其他工具无法解决的问题，包括速度、可靠性、简单性和可链接性。他们采用了一些小而相互补充的方法来实现这些目标，其中包括使用gcov块覆盖率选择最佳测试用例，使用进化算法进行fuzz，通过精心修剪语料库或跳过不可修剪但非功能性的输入文件区域等。此外，AFL还可以处理资源密集型或交互式工具，使用户能够使用更轻量级的目标创建有趣的测试用例。总之，AFL旨在发现有趣的漏洞，并且在这方面表现出色。</p>
</blockquote>
<h2 id="0-设计说明design-statement" class="heading-element">
  <a href="#0-%e8%ae%be%e8%ae%a1%e8%af%b4%e6%98%8edesign-statement" class="heading-mark"></a>0. 设计说明(Design statement)</h2><p>American Fuzzy Lop（AFL）致力于不局限于任何单一的操作原则(singular principle of operation)，也不仅仅是为了证明某个特定理论。这款工具更像是一套在实际操作中经过测试、效果出乎意料的优秀技巧的组合，而且这些技巧是我当时能想到的最简单、最可靠的实现方式。</p>
<p>这些特性的诞生很大程度上得益于轻量级的插桩技术instrumentation 支持，这为AFL的发展提供了坚实的基础。但我们应该把这些技术看作是达到目的的手段，而非终极目标。AFL真正遵循的核心原则是速度、可靠性和易用性(ease(缓解) of use)。</p>
<h2 id="1-覆盖率检测coverage-measurements" class="heading-element">
  <a href="#1-%e8%a6%86%e7%9b%96%e7%8e%87%e6%a3%80%e6%b5%8bcoverage-measurements" class="heading-mark"></a>1. 覆盖率检测(Coverage measurements)</h2><p>注入到编译后程序中的插桩技术可以捕捉<strong>分支</strong>（即代码执行的不同路径）的覆盖情况，并粗略统计每个分支的执行次数。这种技术在分支点注入的代码本质上相当于以下内容：</p>
<div class="highlight" id="id-1"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">  <span class="n">cur_location</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">COMPILE_TIME_RANDOM</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">shared_mem</span><span class="p">[</span><span class="n">cur_location</span> <span class="o">^</span> <span class="n">prev_location</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="n">prev_location</span> <span class="o">=</span> <span class="n">cur_location</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span></span></span></code></pre></div><p>这里的 <code>cur_location</code> 值是在编译时随机生成的，目的是简化复杂项目链接过程，并确保 XOR（异或）操作的输出能均匀分布。</p>
<p><code>shared_mem[]</code> 数组是一个 64 KB 的共享内存（SHM）区域，由调用程序传递给被插桩的二进制文件。输出映射中的每一个字节都可以被看作是被插桩代码中特定的<code>[branch_src, branch_dst]</code>元组的一个命中(hit)。</p>
<p>通过选择映射(map)的大小，使得它在几乎所有预定目标中的碰撞都相对较少，这些目标代码的分支数大多在2k到10k之间</p>
<table>
<thead>
<tr>
<th>Branch cnt</th>
<th>Colliding tuples</th>
<th>Example targets</th>
</tr>
</thead>
<tbody>
<tr>
<td>1,000</td>
<td>0.75%</td>
<td>giflib, lzo</td>
</tr>
<tr>
<td>2,000</td>
<td>1.5%</td>
<td>zlib, tar, xz</td>
</tr>
<tr>
<td>5,000</td>
<td>3.5%</td>
<td>libpng, libwebp</td>
</tr>
<tr>
<td>10,000</td>
<td>7%</td>
<td>libxml</td>
</tr>
<tr>
<td>20,000</td>
<td>14%</td>
<td>sqlite</td>
</tr>
<tr>
<td>50,000</td>
<td>30%</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>同时，它的大小足够小，可以在几微秒内分析映射，并毫不费力地放入二级缓存L2中。</p>
<p>与简单的块覆盖相比，这种形式的覆盖提供了更多程序执行路径的信息(insight)。并且，它可以简单地区分以下执行路径(trace)：</p>
<pre tabindex="0"><code>  A -&gt; B -&gt; C -&gt; D -&gt; E (tuples: AB, BC, CD, DE)
  A -&gt; B -&gt; D -&gt; C -&gt; E (tuples: AB, BD, DC, CE)</code></pre><blockquote>
<p><a href="https://stackoverflow.com/questions/35844439/what-is-the-difference-between-block-coverage-and-branch-coverage"target="_blank" rel="external nofollow noopener noreferrer">What is the difference between block coverage and branch coverage?</a></p>
<p>大写字母代表程序基本块之间的边，每一条边都有一个随机化的ID（即<code>cur_location</code>），值分别为A-E，所以</p>
<p>B-&gt;C-&gt;D 路径表现为 <code>shared_mem[(B &gt;&gt; 1) ^ C]++ shared_mem[(C &gt;&gt; 1) ^ D]++</code></p>
<p>B-&gt;D-&gt;C 路径表现为 <code>shared_mem[(B &gt;&gt; 1) ^ D]++ shared_mem[(D &gt;&gt; 1) ^ C]++</code></p>
<p>显然是可以区分的。但是块覆盖只会记录 B,C,D 块均命中，却无法区分。</p>
</blockquote>
<p>这有助于发现底层代码中的细微故障情况，因为安全漏洞通常更多地与意外或不正确的<strong>状态转换</strong>相关，而不仅仅是达到一个新的基本块。</p>
<p>前面所示的伪代码的最后一行中进行移位操作是为了保持元组的方向性（如果没有这个，A ^ B 将与 B ^ A 无法区分）并且可以区分不同的紧密循环(tight loops)（否则 , A ^ A 显然等于 B ^ B)。</p>
<blockquote>
<p>如果不移位:
对于路径 A-&gt;B 与 B-&gt;A 表现均为 <code>shared_mem[A ^ B]++</code> ，无法区分
对于环形路径 A-&gt;A 与 B-&gt;B 表现均为 <code>shared_mem[0]++</code>，无法区分</p>
</blockquote>
<p>由于 Intel CPU 上缺乏简单的饱和运算指令(saturating arithmetic opcodes)，意味着命中计数器有时可能会回绕至零。尽管这种情况相对罕见且局限性较强，但它被视为一个可以接受的性能折中方案(trade-off)。</p>
<blockquote>
<p>通俗来讲，<a href="https://en.wikipedia.org/wiki/Saturation_arithmetic"target="_blank" rel="external nofollow noopener noreferrer">饱和运算</a>就是具有上下界的算数指令，比如一个规定算数范围为-100~100的饱和算数指令中，(40+80)-(50+60)=100-100=0（而不是10）</p>
<p>Intel 没有使用饱和算数指令，而使用<a href="https://en.wikipedia.org/wiki/Modular_arithmetic"target="_blank" rel="external nofollow noopener noreferrer">modular arithmetic</a>. 导致最大值的溢出会向最小值保留，比如最常见的正溢出与负溢出</p>
</blockquote>
<h2 id="2-新路径检测detecting-new-behaviors" class="heading-element">
  <a href="#2-%e6%96%b0%e8%b7%af%e5%be%84%e6%a3%80%e6%b5%8bdetecting-new-behaviors" class="heading-mark"></a>2. 新路径检测(Detecting new behaviors)</h2><p>Fuzzer 全程维护这个全局的元组map <code>shared_mem[]</code>；这些数据能在各自的路径中被快速对比，并仅需几个<code>dword</code>或<code>qword</code>宽度的指令和一个简单的循环即可更新。</p>
<p>当变异(mutated)的输入产生包含新元组的执行路径时，相应的输入文件将被保留并路由以供稍后进行额外处理（第三部分介绍）。 在执行路径中不触发新的局部状态转换的输入（即不产生新的元组）将被丢弃，即使它们产生了新的全局控制流。</p>
<p>这种方法允许对程序状态进行非常细粒度(fine-grained)和长期的探索，同时不必对复杂的执行路径执行任何复杂计算和不可靠的的全局比较，同时也能防止搜寻过程中的路径爆炸(path explosion)。</p>
<p>为了展示这种算法的特点，我们可以考虑以下情况：第二个执行轨迹因为包含了新的元组（CA, AE）而被认为是一个显著的新路径：</p>
<div class="highlight" id="id-3"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">##1: A -&gt; B -&gt; C -&gt; D -&gt; E
</span></span></span><span class="line"><span class="cl"><span class="cp">##2: A -&gt; B -&gt; C -&gt; A -&gt; E</span></span></span></code></pre></div><p>同时 #2 产生后，#3 就不再认为是有意义的了，尽管以下模式的全局路径截然不同，它还是不会被视为独特的：</p>
<div class="highlight" id="id-4"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">##3: A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; A -&gt; B -&gt; C -&gt; D -&gt; E</span></span></span></code></pre></div><p>除了检测新元组外，Fuzzer 还粗略考虑元组命中数。 被分为以下几个桶(buckets)：</p>
<div class="highlight" id="id-5"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="o">-</span><span class="mi">127</span><span class="p">,</span> <span class="mi">128</span><span class="o">+</span></span></span></code></pre></div><p>在某种程度上，桶 buckets 的数量是是实现过程中的一个特点，它允许把插桩技术生成的 8-bit计数器直接映射到模糊测试器执行文件所依赖的一个8-position位置的位图上。这个位图用于跟踪每个元组已经出现的执行次数。前者由插桩产生，后者由 AFL 运行时路径已出现的元组数来计数。</p>
<p>在如果变化仅发生在单个桶的范围内，则会被忽略；但如果从一个桶到另一个桶，则这种转变会被标记为程序控制流中的一个有趣的变化。也会指导下一阶段的进化过程 evolutionary process .(见下一章)</p>
<p>命中计数行为提供了一种区分潜在有趣的控制流变化的方法，比如一个通常只执行一次的代码块突然执行了两次。同时，它对经验上不太显著的变化（例如循环从47个周期变成48个周期）相当不敏感。计数器还在某种程度上“意外地”防止了在密集的执行路径中元组碰撞的发生。</p>
<p>执行过程受到<strong>内存</strong>和<strong>执行时间</strong>限制的限制；默认情况下，超时时间设置为初始化标准执行速度对应时间的5倍，大概 20 ms。这些激进的超时时间旨在防止模糊测试器陷入陷阱中而导致性能严重下降，例如，为了提高 1% 的覆盖率却导致速度慢了 100 倍；我们从实用角度出发，拒绝这种情况，并希望 fuzzer 可以找到一个更轻松的方式来遍历相同数量的代码。经验测试，更宽松的时间限制不值得。</p>
<h2 id="3-输入队列变异evolving-the-input-queue" class="heading-element">
  <a href="#3-%e8%be%93%e5%85%a5%e9%98%9f%e5%88%97%e5%8f%98%e5%bc%82evolving-the-input-queue" class="heading-mark"></a>3. 输入队列变异(Evolving the input queue)</h2><p>产生了新的程序状态转换的变异测试用例会被添加到输入队列中，并用作新一轮次 fuzzing 的起点。这些用例是已有测试用例的补充，但并不替换掉已有测试用例。</p>
<p>与更贪心的遗传算法相比，这种方法允许AFL逐步探索底层数据格式的各种不相交且可能相互不兼容的特征，如下图所示：</p>
<p><img loading="lazy" src="/posts/2023-5aflwritepaper/afl_gzip.png" alt="img" srcset="/posts/2023-5aflwritepaper/afl_gzip.png?size=small, /posts/2023-5aflwritepaper/afl_gzip.png?size=medium 1.5x, /posts/2023-5aflwritepaper/afl_gzip.png?size=large 2x" data-title="img" style="--width: 2600px;--aspect-ratio: 2600 / 2150;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>还有一些对于此算法实践的结果讨论：</p>
<ul>
<li><a href="http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html</a></li>
<li><a href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-nobody-expects-cdata-sections.html</a></li>
</ul>
<blockquote>
<p><code>pulling-jpegs-out-of-thin-air</code>:
本文介绍了afl-fuzz工具的一个有趣的应用场景。作者创建了一个只包含&quot;hello&quot;字符串的文本文件，并将其作为输入交给了一个期望接收JPEG图像的程序。由于该输入文件与有效的图片格式不符，因此该程序会立即拒绝该输入。然而，afl-fuzz可以利用轻量级汇编级别的插装技术，发现将第一个字节设置为0xff触发了被测试应用程序中略微不同的内部代码路径。afl-fuzz将这个测试用例作为下一轮fuzzing的种子。在几百个代和数亿次execve()调用后，afl-fuzz逐渐发现了构成有效JPEG文件的基本控制结构。最终，它成功地合成了一个有效的JPEG图像。作者指出，这种方法不仅可以用于合成JPEG图像，还可以用于压力测试其他类型的解析器。本文还讨论了afl-fuzz工具的局限性，即当目标二进制文件中存在具有大搜索空间的原子执行检查时，可能会对fuzzer造成难以克服的障碍。</p>
</blockquote>
<blockquote>
<p><code>afl-fuzz-nobody-expects-cdata-sections</code>:
本文主要介绍了AFL-fuzz的一个实验结果，即通过随机变异输入文件和轻微调整进程状态来发现程序中的新状态转换。作者最初认为这种方法只能使fuzzer比土豆更聪明一些，但后来发现它可以成功地合成JPEG文件。文章还讨论了AFL-fuzz在探索人类可读格式（如HTML或JavaScript）时的局限性，并介绍了一些解决方案。最后，作者提到了AFL-fuzz在测试libxml2时的惊人表现，尽管这与其设计意图有所违背。</p>
<p>本文介绍了AFL-fuzz在测试XML解析器libxml2时的一个惊人发现。作者最初只是想测试该解析器的基本功能，但在两天内，AFL-fuzz生成了一个包含特殊CDATA部分的XML文件，这个部分很难通过随机变异来发现。作者认为这可能是因为AFL-fuzz在编译插桩二进制文件时使用了-O3 -funroll-loops参数，或者是因为libxml2中的一些字符串比较操作使用了类似的代码结构。作者表示，这个结果让他感到有点神秘，因为它违反了AFL-fuzz的设计限制之一。作者还提到，尽管AFL-fuzz能够发现某些高度冗长的文本语法，但在其他情况下，使用简单的语法感知、基于模板的工具可能更加有效。</p>
</blockquote>
<p>这个过程产生的合成语料库本质上是一个“嗯，有新东西！”的输入集合，可以作为后续任何其他测试流程的种子（例如，手动对资源密集型桌面应用程序进行压力测试）。</p>
<p>根据这种方法，对于大多数目标程序，队列的大小通常会增长到1k到10k条记录之间。其中约有10-30%的增长是由于发现新元组，其余的增长则与命中计数的变化有关。这意味着，通过使用元组策略，AFL能够更加高效地生成测试用例，并且能够更快地探索目标程序的不同执行路径。</p>
<p>以下表格比较了在使用几种指导 fuzzing 的方法时，发现文件语义（file syntax）和探索程序状态的相对能力。每种策略下的测试结果都包括块（Blocks）覆盖率、边（Edges）覆盖率、命中最多的边计数变量（Edge hit cnt var）以及在达到最高覆盖率时生成的测试用例。测试使用的目标是GNU patch 2.7.3，编译选项为-O3，并使用一个虚拟文本文件作为种子进行测试。测试过程中使用了afl-fuzz进行单次输入队列遍历。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Fuzzer guidance strategy used</th>
<th style="text-align:center">Blocks reached</th>
<th style="text-align:center">Edges reached</th>
<th style="text-align:center">Edge hit cnt var</th>
<th style="text-align:center">Highest-coverage test case generated</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(Initial file)</td>
<td style="text-align:center">156</td>
<td style="text-align:center">163</td>
<td style="text-align:center">1.00</td>
<td style="text-align:center">(none)</td>
</tr>
<tr>
<td style="text-align:center">Blind fuzzing S</td>
<td style="text-align:center">182</td>
<td style="text-align:center">205</td>
<td style="text-align:center">2.23</td>
<td style="text-align:center">First 2 B of RCS diff</td>
</tr>
<tr>
<td style="text-align:center">Blind fuzzing L</td>
<td style="text-align:center">228</td>
<td style="text-align:center">265</td>
<td style="text-align:center">2.23</td>
<td style="text-align:center">First 4 B of -c mode diff</td>
</tr>
<tr>
<td style="text-align:center">Block coverage</td>
<td style="text-align:center">855</td>
<td style="text-align:center">1,130</td>
<td style="text-align:center">1.57</td>
<td style="text-align:center">Almost-valid RCS diff</td>
</tr>
<tr>
<td style="text-align:center">Edge coverage</td>
<td style="text-align:center">1,452</td>
<td style="text-align:center">2,070</td>
<td style="text-align:center">2.18</td>
<td style="text-align:center">One-chunk -c mode diff</td>
</tr>
<tr>
<td style="text-align:center">AFL model</td>
<td style="text-align:center">1,765</td>
<td style="text-align:center">2,597</td>
<td style="text-align:center">4,99</td>
<td style="text-align:center">Four-chunk -c mode diff</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在这个测试中，使用了以下几种引导策略：</p>
<ul>
<li>初始文件（Initial file）：使用虚拟文本文件作为种子，随机生成测试用例。</li>
<li>盲目fuzzing S（Blind fuzzing S）：随机生成测试用例，并在测试用例中添加一些特定的字节序列，以探索程序的不同执行路径。</li>
<li>盲目fuzzing L（Blind fuzzing L）：与盲目fuzzing S类似，但添加的字节序列更长。</li>
<li>块覆盖率（Block coverage）：使用AFL的块覆盖率引导策略，生成测试用例以尽可能覆盖目标程序的基本块。</li>
<li>边覆盖率（Edge coverage）：使用AFL的边覆盖率引导策略，生成测试用例以尽可能覆盖目标程序的基本边。</li>
<li>AFL模型（AFL model）：使用AFL的深度学习模型进行引导，生成测试用例以尽可能覆盖目标程序的执行路径。</li>
</ul>
<p>块覆盖率，边覆盖率，边命中率，最高覆盖率下生成的测试用例</p>
</blockquote>
<p>盲fuzzing的第一个条目（“S”）代表仅执行了一轮测试；第二组条目（“L”）展示了fuzzer在循环中运行了与插桩测试相当的执行周期数，这需要更多的时间来完全处理不断增长的队列。</p>
<blockquote>
<p>Blind fuzzing 为盲变异，有 S 与 L 两种方式，均相当于对照组
execution cycles 就是字面意思，即计算机体系结构中取指、译码、执行中的执行周期。
instrumented runs 可以翻译成插桩运行，也可以认为是有指导、有反馈地运行，指代的就是后续 Block, Edge coverage, AFL model 这些有指导的、不盲的 fuzzing.
保持 Blind fuzzing 与后续 instrumented runs 的循环执行周期数大致相近，才有比较的意义。
插桩运行时队列生长的速度慢，因为需要反复分析；盲 fuzzing 弄出一个测试用例队列是最快的，但能不能有效就不一定了。</p>
</blockquote>
<p>在另一个单独的实验中，获得了大致相似的结果。该测试中，研究人员对fuzzer进行了修改，在这里让 fuzzer 在编译时去掉所有的随机 fuzzing 阶段，仅保留一系列基本的、顺序的操作，如遍历位翻转。由于这种模式不能改变输入文件的大小，因此实验使用了一个有效的、统一的 diff 输出作为种子：</p>
<table>
<thead>
<tr>
<th>Queue extension strategy used</th>
<th>Blocks reached</th>
<th>Edges reached</th>
<th>Edge hit cnt var</th>
<th>Number of unique crashes found</th>
</tr>
</thead>
<tbody>
<tr>
<td>(Initial file)</td>
<td>624</td>
<td>717</td>
<td>1.00</td>
<td>-</td>
</tr>
<tr>
<td>Blind fuzzing</td>
<td>1,101</td>
<td>1,409</td>
<td>1.60</td>
<td>0</td>
</tr>
<tr>
<td>Block coverage</td>
<td>1,255</td>
<td>1,649</td>
<td>1.48</td>
<td>0</td>
</tr>
<tr>
<td>Edge coverage</td>
<td>1,259</td>
<td>1,734</td>
<td>1.72</td>
<td>0</td>
</tr>
<tr>
<td>AFL model</td>
<td>1,452</td>
<td>2,040</td>
<td>3.16</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>正如之前提到的，一些关于遗传算法fuzzing的早期工作依赖于维护单一测试用例并不断变异它以最大化覆盖率。至少在上述测试中，这种“贪婪”的方法似乎并没有比盲fuzzing策略带来供显著的优势。换句话说，这段文字表明在进行fuzzing测试时，使用单个测试用例并不一定比使用其他策略更有效。</p>
<h2 id="4-精简语料库culling-the-corpus" class="heading-element">
  <a href="#4-%e7%b2%be%e7%ae%80%e8%af%ad%e6%96%99%e5%ba%93culling-the-corpus" class="heading-mark"></a>4. 精简语料库(Culling the corpus)</h2><p>上述列出的渐进式状态探索方法意味着，在进行fuzzing测试时，后期生成的一些测试用例的<strong>边覆盖</strong>可能会比它们的“祖先”用例提供的覆盖更加全面。</p>
<p>为了优化fuzzing结果，AFL会定期使用一种快速算法重新评估队列：选择一个更小的测试用例子集，这些用例仍然覆盖到目前为止见到的每个元组，并且它们的特征使它们对工具特别有利。</p>
<p>这个算法通过为队列中的每个条目分配一个分数来工作，这个分数与其执行延迟和文件大小成正比；然后选择每个元组得分最低的候选用例。</p>
<blockquote>
<p>“算法性能优化”（algorithmic performance tuning）策略。这个策略是AFL用来探索程序状态和语法的一种方式。在这个策略中，AFL会先把所有的输入文件进行元组化操作，将它们转换成一个个元组，然后按照一定的顺序逐个进行处理。处理的过程包括以下几个步骤：</p>
</blockquote>
<p>接下来，这些元组会按照以下简单的工作流程依次处理：</p>
<ol>
<li>找到下一个还没有在临时工作集中出现的元组；</li>
<li>定位到这个元组对应的最佳队列条目（winning queue entry）；</li>
<li>将此元素产生的路径上出现的所有元组加入当前工作集</li>
<li>如果工作集中还有缺失的元组，则回到第1步继续查找。</li>
</ol>
<p>这个过程会不断循环，直到所有的元组都被处理完毕。</p>
<p>在这个过程中，AFL会生成一个“受青睐”的输入文件集合，这些文件集合通常比起始数据集小5-10倍。非“受青睐”的输入文件不会被丢弃，但当它们在队列中遇到时，会以不同的概率被跳过：</p>
<ul>
<li>
<p>如果队列中有新的、尚未进行fuzzing的“受青睐”文件，则99%的非“受青睐”文件将被跳过，以便处理“受青睐”文件。</p>
</li>
<li>
<p>如果队列中没有新的“受青睐”文件：</p>
<ul>
<li>
<p>如果当前的非“受青睐”文件已经进行过fuzzing，它将有 95% 的概率被跳过。</p>
</li>
<li>
<p>如果该文件还没有进行任何fuzzing，则跳过的概率下降到75%。</p>
</li>
</ul>
</li>
</ul>
<p>通过这种方式，会更频繁地处理“受青睐”的文件，而不是浪费时间处理那些已经被处理过的或者不太可能产生漏洞的文件。</p>
<p>根据实证测试结果，这种方法在队列循环速度(queue cycling speed)和测试用例多样性(test case diversity)之间实现了合理的平衡。</p>
<p>可以使用 afl-cmin 对输入或输出的测试集进行更精细但速度较慢的筛选。这个工具会永久性地去除多余的条目，并生成一个更小的语料库，适用于 afl-fuzz 或其他外部工具。</p>
<h2 id="5-修剪输入文件trimming-input-files" class="heading-element">
  <a href="#5-%e4%bf%ae%e5%89%aa%e8%be%93%e5%85%a5%e6%96%87%e4%bb%b6trimming-input-files" class="heading-mark"></a>5. 修剪输入文件(Trimming input files)</h2><p>文件大小对fuzzing的性能有重大影响，原因有两个，一是大文件使目标二进制文件运行变慢，二是它们降低了变异触及关键的格式控制结构而非冗余数据块的概率，从而降低测试的效率。这在<code>perf_tips.txt</code>中有更详细的讨论。</p>
<p>抛开用户可能提供低质量起始语料库的可能性不谈，某些类型的变异可能逐渐增加生成文件的大小，因此阻止这种趋势很重要。</p>
<p>幸运的是，插桩技术提供了一种简单的方法，可以自动裁剪输入文件，同时确保这些更改不会影响执行路径。</p>
<p>“instrumentation feedback”技术可以帮助AFL自动修剪输入文件，以提高fuzzing测试的效率和质量。AFL在执行fuzzing测试时，通过对程序进行插桩（instrumentation）来获取有关程序执行路径的反馈信息。利用这些反馈信息，AFL可以自动识别输入文件中不必要的部分，并将其删除，从而减小文件大小。同时，由于这些更改不会影响程序的执行路径，因此可以确保测试用例的质量不会受到影响。</p>
<p>AFL中内置的修剪器(trimmer)会尝试按顺序删除具有可变长度和步长的数据块；任何不影响路径图校验和的删除操作都将被提交到磁盘。这个减枝器并没有设计地非常准确详尽；相反，它试图在<strong>精度</strong>和<strong>执行 execve() 调用次数</strong>之间寻求平衡。平均每个文件的优化效果大约在 5-20% 左右。</p>
<p>与内置的修剪器不同，<code>afl-tmin</code>使用更为彻底、迭代的算法，并尝试对修剪后的文件进行字符标准化(alphabet normalization)。afl-tmin的操作如下所述：</p>
<p>首先，AFL会自动选择操作模式。如果初始输入会导致目标二进制文件崩溃，afl-tmin 将以非插桩模式运行，不断尝试去调整输入让它变得更简单的同时仍然可以导致目标程序崩溃；如果目标没有崩溃，该工具使用插桩模式，只保留那些能产生完全相同执行路径的调整。</p>
<p>最小化的算法包括以下步骤：</p>
<ol>
<li>
<p>尝试用大步长将大块数据置零。经验证，这将会为后续更细粒度的工作铺路从而降低 execve 调用。</p>
</li>
<li>
<p>以二分搜索的方式进行块删除，逐渐减小块的大小和步长。</p>
</li>
<li>
<p>通过计算字符数量并尝试批量将每个字符替换为零值来进行字母表规范化。</p>
</li>
<li>
<p>最后，在非零字节上执行逐字节标准化。</p>
</li>
</ol>
<p>afl-tmin 使用 ASCII 数字 &lsquo;0&rsquo; 替换零值，而不是使用 0x00 字节。这么做的原因是这种修改对文本解析的干扰较小，因此更有可能成功地最小化文本文件。</p>
<p>这里使用的算法虽然不如学术研究中提出的一些其他测试用例最小化方法那样复杂，但它需要的执行次数更少，在大多数实际应用中能产生与其相媲美的结果。</p>
<h2 id="6-模糊测试策略fuzzing-strategies" class="heading-element">
  <a href="#6-%e6%a8%a1%e7%b3%8a%e6%b5%8b%e8%af%95%e7%ad%96%e7%95%a5fuzzing-strategies" class="heading-mark"></a>6. 模糊测试策略(Fuzzing strategies)</h2><p>插桩技术提供的反馈让我们能更容易理解各种fuzzing策略的价值，并优化它们的参数，以确保这些策略在各种不同的文件类型上都能同样有效。afl-fuzz 使用的策略通常是格式无关的(format-agnostic)，在以下链接中有更详细的讨论：</p>
<pre><code>http://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html
</code></pre>
<blockquote>
<p>这篇文章讨论了二进制fuzzing的策略，以及它们的有效性和限制。文章提到，成功的fuzzer取决于它们的fuzzing策略。如果对输入文件做出的更改过于保守，fuzzer将实现非常有限的覆盖率。如果调整过于激进，则会导致大多数输入在非常早期的阶段失败解析，浪费CPU周期并产生难以调查和排除故障的混乱测试用例。</p>
<p>文章介绍了AFL（American Fuzzy Lop）的设计，该设计提供了一种罕见的反馈循环：您可以仔细测量哪些类型的更改实际上导致代码中新分支的发现。AFL通过一系列逐渐复杂但详尽和确定性的fuzzing策略（例如顺序位翻转和简单算术）来接近每个新输入文件，然后再进入纯随机行为。这样做的原因是先生成最简单和最优雅的测试用例；但是，该设计还提供了一种非常好的方法来量化每种新策略带来的价值 - 以及我们是否需要它。</p>
<p>文章提到了几种具体的fuzzing策略，包括Walking bit flips、Walking byte flips、Simple arithmetics、Known integers、Stacked tweaks和Test case splicing。每种策略都有其独特的优点和缺点，并且效果因格式而异。例如，Walking bit flips是最基本的策略之一，可以发现大约70个新路径，但成本相对较高，每个输入文件的每个字节需要八个execve()调用。另一方面，Simple arithmetics可以以相对较低的成本发现更复杂的条件，但成本仍然相对较高，每个输入文件的每个字节需要约20个execve()调用。</p>
<p>总之，文章提供了有关二进制fuzzing策略的详细信息，以及这些策略的有效性和限制。这对于正在开发自己的fuzzer的人们来说可能会很有用。</p>
</blockquote>
<p>特别是在早期阶段，afl-fuzz大部分工作都是高度确定性的，随机堆叠（stacked tweaks）的修改和测试用例的拼接（test case splicing）只在后期才会进行。这些确定性策略包括：</p>
<ul>
<li>顺序位翻转，有不同的长度和步长</li>
<li>顺序小整数加减</li>
<li>顺序插入特殊整数（0、1、<code>INT_MAX</code>等）</li>
</ul>
<p>采用确定性步骤的初衷与它们产生紧凑的测试用例和在非崩溃输入与崩溃输入之间保持小差异的倾向相关。</p>
<p>在确定性fuzzing完成后，AFL会使用非确定性策略，包括堆叠位翻转、插入、删除、算术运算和不同测试用例的拼接。这些策略的相对收益和execve()成本在上述博客文章中进行了讨论。</p>
<p>由于 historical_notes.txt 文档中讨论的原因（主要包括性能、简单性和可靠性），AFL 通常不尝试推断特定变异与程序状态之间的关系；这些 fuzzing 步骤只是名义上的盲（随机），它们会也只会受输入队列指导。</p>
<p>即便如此，这套规则也有一个（不太重要的）例外：当一个新的队列条目经过初始的确定性fuzzing步骤时，如果观察到对文件中某些区域的调整对执行路径的校验和没有影响，那么它们可以被排除在确定性fuzzing的其余阶段之外，fuzzer可以直接进行随机调整。特别是对于冗长的、可读性高的数据格式，这可以将执行次数降低10-40%，而覆盖率几乎没有下降。在极端情况下，例如通常块对齐的tar档案，收益可能高达90%。</p>
<p>AFL中的一种优化技巧，即&quot;修剪输入文件和控制文件大小&quot;。
具体来说，AFL使用一种称为&quot;effector maps&quot;的机制来记录测试过程中每个输入文件的状态和效果，并根据这些信息来决定下一步的操作。这些&quot;effector maps&quot;是本地的，即每个队列条目都有自己的&quot;effector maps&quot;，并且只在不改变底层文件大小或布局的确定性阶段保持有效。通过这种机制，AFL能够高效、可靠地进行fuzzing测试，并且这种机制的实现也相对简单。</p>
<h2 id="7-字典构建dictionaries" class="heading-element">
  <a href="#7-%e5%ad%97%e5%85%b8%e6%9e%84%e5%bb%badictionaries" class="heading-mark"></a>7. 字典构建(Dictionaries)</h2><p>AFL使用插桩技术来获取程序执行时的反馈信息，并根据这些信息自动识别输入文件中的语法token。这使得AFL能够检测到预定义或自动检测到的字典的某些组合是否构成了被测试解析器的有效语法。通过这种方式，AFL能够更加智能地生成测试用例，并且能够更好地探索程序状态空间。</p>
<p>这里讨论了 afl-fuzz 是如何实现语法检测的:</p>
<p><a href="http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html</a></p>
<blockquote>
<p>这段内容主要讲述了AFL-fuzz在处理语法复杂的数据格式时存在的局限性，以及一种通过构建基本语法单元列表来改善AFL-fuzz对这些格式的测试能力的方法。作者提出了一个简单的算法，该算法可以通过检测连续的比特翻转触发与邻近区域不同但整个字节序列中一致的执行路径来识别语法单元，并将其添加到字典中以供后续随机组合。这种方法虽然不能替代手工构建的关键字列表，但可以帮助那些没有时间或倾向于构建完整字典的人们。</p>
</blockquote>
<p>AFL通过将基本的、容易获取的语法token以纯随机方式组合在一起，利用插桩技术和进化设计队列提供反馈机制，以区分无意义的变异和触发仪器代码中新行为的变异，并逐步在这个发现的基础上构建更复杂的语法。</p>
<blockquote>
<p>换句话说，AFL使用随机测试数据来探索程序状态，从而找到新的测试路径和漏洞。同时，AFL还利用进化算法对测试数据进行优化，以获得更好的测试效果。</p>
</blockquote>
<p>字典可以帮助fuzzer快速重构高度冗长和复杂的语言的语法，例如JavaScript、SQL或XML。上面提到的博客文章中给出了生成的几个SQL语句的示例。字典是一种用于指导fuzzer生成有效测试数据的技术，它可以包含一些预定义的语法标记或关键词，以帮助fuzzer更好地理解程序语法结构，并生成更有意义的测试数据。在AFL中，字典被用于扩展随机测试数据的范围，以便发现更多的测试路径和漏洞。</p>
<p>有趣的是，AFL的插桩技术还允许fuzzer自动隔离已经存在于输入文件中的语法token。它在通过在翻转比特时定位对程序执行路径产生一致性改变的位置来实现；这表明代码中内置了与预定义值的原子比较。fuzzer依赖于这个信号来构建紧凑的&quot;自动字典&quot;，然后与其他fuzzing策略一起使用。</p>
<h2 id="8-崩溃去重de-duping-crashes" class="heading-element">
  <a href="#8-%e5%b4%a9%e6%ba%83%e5%8e%bb%e9%87%8dde-duping-crashes" class="heading-mark"></a>8. 崩溃去重(De-duping crashes)</h2><p>崩溃去重是一个合格的fuzzing工具中更为重要的问题之一。许多朴素的方法都会遇到问题；特别是，仅查看故障地址可能会导致完全不相关的问题被聚集在一起，如果故障发生在常见的库函数（例如strcmp、strcpy）中，则会出现这种情况；而对调用栈回溯进行校验和可能会导致崩溃计数极度膨胀，如果故障可以通过许多不同的、可能是递归的代码路径到达。</p>
<p>afl-fuzz实现的解决方案认为，如果满足以下两个条件之一，崩溃就是唯一的：</p>
<ul>
<li>崩溃跟踪包含以前未见过的元组。</li>
<li>崩溃跟踪缺少先前所有故障中始终存在的元组。</li>
</ul>
<p>这种方法在早期可能会存在一些路径数量膨胀的问题，但它展示了非常强的自我限制(self-limiting)效果，类似于afl-这种去重方式与执行路径分析的逻辑一起构成了 afl-fuzz 的基石。</p>
<h2 id="9-崩溃调查investigating-crashes" class="heading-element">
  <a href="#9-%e5%b4%a9%e6%ba%83%e8%b0%83%e6%9f%a5investigating-crashes" class="heading-mark"></a>9. 崩溃调查(Investigating crashes)</h2><p>许多类型的崩溃漏洞的可利用性是模糊不清的；afl-fuzz 试图通过提供一个崩溃探索模式(crash exploration mode)来解决这个问题，在这种模式下，一个已知存在漏洞的测试用例会被以与fuzzer正常操作非常相似的方式进行fuzzing，但有一个约束条件，即任何非崩溃的变异都将被丢弃。</p>
<p>很多类型的崩溃的可利用性 exploitability 是难以界定的；afl-fuzz 会尝试使用崩溃调查模式 crash exploration mode 来解决这一问题：规则与正常操作模式类似，但变异过后不崩溃的测试用例会被直接丢弃。</p>
<p>这种解决方法的价值在这篇文章中详细探讨:</p>
<p><a href="http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.blogspot.com/2014/11/afl-fuzz-crash-exploration-mode.html</a></p>
<blockquote>
<p>该文介绍了AFL-fuzz的新功能——崩溃探索模式。在进行fuzzing测试时，发现崩溃问题后需要花费大量时间来确定是否存在安全风险。而使用崩溃探索模式可以很快地生成一组相关但略有不同的崩溃，以便更准确地估计您对故障地址的控制程度，或者找出是否可以通过适当的方式解决越界读取等问题。这项新功能可以使您更加精准地判断崩溃问题是否具有安全风险，而无需花费大量时间进行手动调试。</p>
</blockquote>
<p>该方法使用插桩反馈来探索崩溃程序的状态，以克服模糊的故障条件，然后将新发现的输入隔离出来供人工审查。</p>
<p>对于崩溃来说，与通常的队列元素相反，将崩溃的输入进行减枝是毫无意义的。它们被发现之后就会原封不动的保存，以便将它们与父（未崩溃）元素进行对比分析。也就是说，是否用 afl-tmin 去剪枝都行</p>
<h2 id="10-fork服务器the-fork-server" class="heading-element">
  <a href="#10-fork%e6%9c%8d%e5%8a%a1%e5%99%a8the-fork-server" class="heading-mark"></a>10. fork服务器(The fork server)</h2><p>为了提高性能，afl-fuzz使用了一个&quot;fork server&quot;，其中fuzzing过程中只需经过一次execve()、链接和libc初始化，然后通过利用写时复制(copy-on-write)从停止的进程映像中复制、clone。该实现在这里有更详细的描述：</p>
<p><a href="http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></p>
<blockquote>
<p>该篇文章介绍了在没有execve()的情况下对随机程序进行fuzzing的方法。该方法主要是通过找到一个简单的二进制文件来测试数据解析库的有趣功能，并使用稍微不同的、随机变异的输入在每次运行中执行它。这种方法的优点是可以消除深入文档、理解底层库提供的API并编写自定义代码来测试解析器的需要，同时使模糊测试过程重复和强大。然而，由于特别是对于简单的库，你可能会花费大部分时间等待execve()、链接器和所有库初始化例程完成它们的工作。为了解决这个问题，作者想出了一些方法，例如编写自定义ELF加载器并在使用mprotect()暂时锁定fuzzer本身使用的内存的同时在进程中执行程序，但是这些方法都比较复杂。最终，作者采用了Jann Horn提出的方法，将小型代码注入到被测二进制文件中，以便让execve()发生并在实际程序中提前停止，然后在子进程中使用copy-on-write创建与已加载程序相同的克隆，从而实现了快速、可靠的模糊测试。该方法可以加快许多常见图像库的模糊测试速度。</p>
</blockquote>
<p>fork server是插桩的一个重要组成部分，它只是在第一个被插桩的函数处停止，等待来自afl-fuzz的命令。</p>
<p>在处理快速目标时，使用fork server可以提供相当大的性能提升，通常在1.5倍到2倍之间。除此之外，还有两种模式可以使用：</p>
<ul>
<li>
<p>在手动（“延迟”）( manual (“deferred”) mode )模式下使用fork server，跳过较大的、用户选择的初始化代码块。这需要对目标程序进行非常小的代码更改，并且对于某些目标，可以产生10倍以上的性能提升。</p>
</li>
<li>
<p>启用“持久化”(persistent mode)模式，其中一个进程用于尝试多个输入，大大减少了重复fork()调用的开销。这通常需要对目标程序进行一些代码更改，但可以将快速目标的性能提高5倍或更多，</p>
<ul>
<li>近似于进程内fuzzing作业的好处，同时仍然保持非常强大的隔离性，使得fuzzer进程和目标二进制文件之间的隔离非常可靠。</li>
</ul>
</li>
</ul>
<h2 id="11-并行处理parallelization" class="heading-element">
  <a href="#11-%e5%b9%b6%e8%a1%8c%e5%a4%84%e7%90%86parallelization" class="heading-mark"></a>11. 并行处理(Parallelization)</h2><p>并行机制依赖于定期检查由独立运行的其他CPU核心或远程机器产生的队列，并有选择地拉取在本地尝试时产生尚未被该fuzzer看到的行为的测试用例。</p>
<p>这种方法极大地提高了fuzzer设置的灵活性，包括对共同数据格式的不同解析器运行同步实例。此外，如果想了解更多关于这种设计的信息，请参阅<code>parallel_fuzzing.txt</code>。</p>
<h2 id="12-二进制插桩binary-only-instrumentation" class="heading-element">
  <a href="#12-%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%8f%92%e6%a1%a9binary-only-instrumentation" class="heading-mark"></a>12. 二进制插桩(Binary-only instrumentation)</h2><p>AFL使用一个在“用户”模式下单独构建的QEMU版本来完成。这也允许执行跨架构代码，例如在x86上运行ARM二进制文件。</p>
<p>QEMU将基本块作为翻译单元，插桩是在此之上实现的，并使用大致类似于编译时Hook的模型。</p>
<div class="highlight" id="id-6"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">block_address</span> <span class="o">&gt;</span> <span class="n">elf_text_start</span> <span class="o">&amp;&amp;</span> <span class="n">block_address</span> <span class="o">&lt;</span> <span class="n">elf_text_end</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">cur_location</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_address</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">block_address</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">shared_mem</span><span class="p">[</span><span class="n">cur_location</span> <span class="o">^</span> <span class="n">prev_location</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="n">prev_location</span> <span class="o">=</span> <span class="n">cur_location</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><blockquote>
<p>这段代码检查基本块地址是否在ELF文件的文本段（.text）中，如果是，则将当前位置和前一个位置异或后存储在共享内存中，并将当前位置右移一位作为前一个位置。这样可以记录程序执行路径并用于AFL的fuzzing测试。</p>
</blockquote>
<p>第二行中的移位异或混淆（shift-and-XOR-based scrambling）。这种混淆是为了掩盖指令对齐的影响，因为指令对齐可能会导致基本块地址的低位不同。</p>
<p>此外，由于像QEMU、DynamoRIO和PIN等二进制翻译器的启动速度比较慢，为了解决这个问题，QEMU模式利用了类似于编译器插桩代码使用的fork server。它会在一个已经初始化并暂停在 <code>_start</code> 处的进程中生成多个副本，从而加快启动速度。</p>
<p>首次翻译新的基本块也会产生相当大的延迟。为了解决这个问题，AFL fork server通过在正在运行的模拟器和父进程之间提供一个通道来进行扩展。该通道用于通知父进程有关任何新遇到的块的地址，并将它们添加到翻译缓存中，以便将来的子进程可以使用。</p>
<p>由于这两个优化，QEMU模式的开销大约是白盒的2-5倍，而PIN的开销超过100倍。</p>
<h2 id="13-afl分析工具the-afl-analyze-tool" class="heading-element">
  <a href="#13-afl%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7the-afl-analyze-tool" class="heading-mark"></a>13. AFL分析工具(The afl-analyze tool)</h2><p>文件格式分析器 file format analyzer 是前面讨论的最小化算法的简单扩展；该工具不是试图删除无操作块，而是对输入文件执行一系列的字节翻转，后给输入文件执行的各个字节做注解与分类。</p>
<p>它的分类策略如下：</p>
<p>它使用以下分类方案：</p>
<ul>
<li>
<p>无操作块(No-op blocks):</p>
<ul>
<li>位翻转不会对控制流产生明显变化的段。</li>
<li>常见的例子可能是注释部分、位图文件中的像素数据等。</li>
</ul>
</li>
<li>
<p>表面内容(Superficial content)</p>
<ul>
<li>段落中有些但不是全部位翻转会导致一些控制流的变化。</li>
<li>例如，富文本文档中的字符串（如XML、RTF）。</li>
</ul>
</li>
<li>
<p>关键流(Critical stream)</p>
<ul>
<li>一系列字节，其中所有位翻转以不同但相关的方式改变控制流。</li>
<li>这可能是压缩数据、非原子比较的关键字或魔数等。</li>
</ul>
</li>
<li>
<p>疑似长度字段(Suspected length field)</p>
<ul>
<li>小的、原子整数，在任何情况下都会引起一致的程序控制流变化</li>
<li>这往往预示着长度检测的错误。</li>
</ul>
</li>
<li>
<p>疑似校验和或魔法整数(Suspected cksum or magic int)</p>
<ul>
<li>一个整数，行为类似于长度字段，但其数值使得长度解释不太可能。</li>
<li>预示这是一个校验和或其他魔数。</li>
</ul>
</li>
<li>
<p>疑似校验和块(Suspected checksummed block)</p>
<ul>
<li>一个长的数据块，任何更改总是触发相同的新执行路径。</li>
<li>可能是在任何后续解析之前未通过校验和或类似完整性检查而导致的。</li>
</ul>
</li>
<li>
<p>魔数字段(Magic value section)</p>
<ul>
<li>一种通用的标记，更改会导致前面概述的二进制行为类型，但不符合其他任何条件。</li>
<li>可能是一个原子比较的关键字或其他东西。</li>
</ul>
</li>
</ul>
<h2 id="todo" class="heading-element">
  <a href="#todo" class="heading-mark"></a>TODO</h2><ul>
<li>link</li>
<li><a href="https://blog.csdn.net/weixin_42110652/article/details/122093156"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/weixin_42110652/article/details/122093156</a></li>
</ul>
<p>ref:</p>
<blockquote>
<p><a href="https://lcamtuf.coredump.cx/afl/technical_details.txt"target="_blank" rel="external nofollow noopener noreferrer">https://lcamtuf.coredump.cx/afl/technical_details.txt</a></p>
<p>afl设计目标和动机的讨论地址: <a href="http://lcamtuf.coredump.cx/afl/historical_notes.txt"target="_blank" rel="external nofollow noopener noreferrer">http://lcamtuf.coredump.cx/afl/historical_notes.txt</a>
<a href="https://xidoo.top/2022/01/afl-white-book/"target="_blank" rel="external nofollow noopener noreferrer">https://xidoo.top/2022/01/afl-white-book/</a>
<a href="https://www.jianshu.com/p/cc7a486e5adb"target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/cc7a486e5adb</a>
<a href="https://dowob.cn/2020/02/13/afl%E7%99%BD%E7%9A%AE%E4%B9%A6/"target="_blank" rel="external nofollow noopener noreferrer">https://dowob.cn/2020/02/13/afl%E7%99%BD%E7%9A%AE%E4%B9%A6/</a>
<a href="https://www.cnblogs.com/0xHack/p/9407640.html"target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/0xHack/p/9407640.html</a>
<a href="https://zhuanlan.zhihu.com/p/529960677"target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/529960677</a>
<a href="https://blog.csdn.net/weixin_42110652/article/details/122093156"target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/weixin_42110652/article/details/122093156</a></p>
</blockquote>
<h2 id="附-afl设计目标和动机的讨论historical-notes" class="heading-element">
  <a href="#%e9%99%84-afl%e8%ae%be%e8%ae%a1%e7%9b%ae%e6%a0%87%e5%92%8c%e5%8a%a8%e6%9c%ba%e7%9a%84%e8%ae%a8%e8%ae%bahistorical-notes" class="heading-mark"></a>附: AFL设计目标和动机的讨论(historical notes)</h2><ol>
<li>影响</li>
</ol>
<p>简而言之，afl-fuzz的灵感主要来自于Tavis Ormandy在2007年所做的工作。Tavis使用gcov块覆盖率从大量数据中选择最佳的测试用例，并将它们作为传统模糊测试工作流的起点，做了一些非常有说服力的实验。</p>
<p>（所谓“有说服力”，是指：获得了大量有趣的漏洞。）</p>
<p>与此同时，Tavis和我都对进化模糊测试很感兴趣。Tavis有他的实验，我则在2007年左右编写了一个名为bunny-the-fuzzer的工具。</p>
<p>Bunny使用了一种与afl-fuzz并没有太大区别的生成算法，但还试图推理各种输入位与程序内部状态之间的关系，希望从中得到一些额外的价值。这种推理/相关性部分可能在某种程度上受到了Will Drewry和Chris Evans等人在同一时间完成的其他项目的启发。</p>
<p>状态相关方法(state correlation approach)在论文中听起来非常诱人，但最终使模糊器变得复杂、脆弱且难以使用；每个目标程序都需要进行一两次调整。因为Bunny的表现并不比不那么复杂的暴力工具好多少，我最终决定放弃它。你仍然可以在以下网址找到它的原始文档：</p>
<p><a href="https://code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc"target="_blank" rel="external nofollow noopener noreferrer">https://code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc</a></p>
<p>也有一些独立的工作。最值得注意的是，那一年早些时候，Jared DeMott在Defcon上做了一个关于基于覆盖率的模糊测试的演讲，该模糊测试依赖于覆盖率作为适应度函数(fitness function)。</p>
<p>Jared的方法与afl-fuzz所做的并不完全相同，但大致相似。他的模糊器试图显式地(explicitly )解决单个输入文件的最大覆盖问题；相比之下，afl仅选择能够做出新事物的情况（这会产生更好的结果-请参见technical_details.txt）。</p>
<p>几年后，Gabriel Campana发布了fuzzgrind，这是一个完全依赖于Valgrind和约束求解器来最大化覆盖率而没有任何暴力位的工具；微软研究人员则广泛讨论了他们仍未公开的基于求解器的SAGE框架。</p>
<p>在过去的六年左右，我还看到了很多学术论文，涉及智能模糊测试（主要关注符号执行）和一些讨论使用遗传算法实现相同目标的概念验证应用程序的论文。我不太相信这些实验的实用性；我怀疑其中许多都遭受了bunny-the-fuzzer的诅咒，在论文和精心设计的实验中很酷，但在其他情况下却无法找到新的、有价值的安全漏洞。</p>
<p>在某些方面，“酷”的解决方案所要竞争的基线比看起来更令人印象深刻，这使得竞争者难以脱颖而出。举个例子，看看Gynvael和Mateusz Jurczyk的工作，将“愚蠢”的模糊测试应用于ffmpeg，现代浏览器和媒体播放器的重要且关键的组件：</p>
<p><a href="http://googleonlinesecurity.blogspot.com/2014/01/ffmpeg-and-thousand-fixes.html"target="_blank" rel="external nofollow noopener noreferrer">http://googleonlinesecurity.blogspot.com/2014/01/ffmpeg-and-thousand-fixes.html</a></p>
<p>轻松地获得与同样复杂软件中最先进的符号执行相当的结果似乎仍然相当不可能，并且迄今为止还没有在实践中证明过。</p>
<p>但是我偏离了主题；最终，归因很难，赞美AFL背后的基本概念可能是一种浪费时间。魔鬼往往隐藏在常常被忽视的细节中，这就带我们来到了&hellip;</p>
<ol start="2">
<li>afl-fuzz的设计目标
简而言之，我认为afl-fuzz的当前实现解决了其他工具似乎无法解决的一些问题：</li>
</ol>
<p>1）速度。当你的“智能”方法需要大量资源时，很难与暴力破解竞争。如果你的仪器使找到一个漏洞的可能性增加了10倍，但运行速度减慢了100倍，那么你的用户就会受到损失。</p>
<p>为避免从一开始就处于劣势，afl-fuzz旨在让你以大致原生速度模糊测试大多数目标-即使它没有添加价值，你也不会损失太多。</p>
<p>此外，该工具利用仪器在几个方面实际上减少了工作量：例如，通过精心修剪语料库或跳过输入文件中不可修剪但非功能性的部分。</p>
<p>2）坚如磐石的可靠性。如果你的方法脆弱且意外失败，很难与暴力破解竞争。自动化测试很有吸引力，因为它简单易用且可扩展；任何违反这些原则的东西都是一种不受欢迎的权衡，意味着你的工具将被使用得更少，并且结果不太一致。</p>
<p>大多数基于符号执行、污点跟踪或复杂语法感知仪器的方法目前在实际目标中相当不可靠。更重要的是，它们的失败模式可能使它们比“愚蠢”的工具更糟糕，这种退化对于经验不足的用户来说可能很难察觉和纠正。</p>
<p>相比之下，afl-fuzz的设计是坚如磐石的，主要是通过保持简单来实现的。实际上，在其核心，它被设计成一个非常好的传统模糊器，拥有各种有趣的、经过深入研究的策略。花哨的部分只是帮助它将工作集中在最重要的地方。</p>
<p>3）简洁性。测试框架的作者可能是唯一真正了解工具提供的所有设置的人，也是唯一可以精确调整它们的人。然而，即使是最基本的模糊测试框架通常也带有无数个旋钮和模糊比率，需要操作者提前猜测。这可能会造成更多的伤害而不是好处。</p>
<p>AFL旨在尽可能避免这种情况。你可以玩的三个旋钮是输出文件、内存限制和覆盖默认自动校准超时的能力。其余部分只是应该正常工作。当它不起作用时，用户友好的错误消息会概述可能的原因和解决方法，并让你立即回到正轨。</p>
<p>4）可链接性。大多数通用模糊器不能轻松地针对资源占用量大或交互重的工具进行测试，这需要创建定制的进程内模糊器或投入大量CPU功率（其中大部分浪费在与我们实际想要测试的代码无直接关系的任务上）。</p>
<p>AFL试图通过允许用户使用更轻量级的目标（例如，独立的图像解析库）创建一小组有趣的测试用例，这些测试用例可以稍后被馈送到手动测试过程或UI测试中来解决这个问题。</p>
<p>如technical_details.txt所述，AFL并不是通过系统地应用单一的总体CS概念来做到这一点的，而是通过尝试各种小型、互补的方法来实现的，这些方法已经被证明比机会更可靠地产生结果。仪器的使用是这个工具箱的一部分，但远非最重要的部分。</p>
<p>最终，重要的是 afl-fuzz 被设计用来发现酷炫的漏洞 - 并且在这方面具有相当强大的记录。</p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2023-05-16 00:00:00">更新于 2023-05-16&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://localhost:1313/posts/2023-5aflwritepaper/" data-title="【译】AFL白皮书" data-hashtags="RE"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://localhost:1313/posts/2023-5aflwritepaper/" data-hashtag="RE"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://localhost:1313/posts/2023-5aflwritepaper/" data-title="【译】AFL白皮书"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/re/" class="post-tag" title="标签 - RE">RE</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/2023-5antidebug/" class="post-nav-item" rel="prev" title="反检测(更新中...)"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>反检测(更新中...)</a>
      <a href="/posts/2023-7-win-syscalljourney/" class="post-nav-item" rel="next" title="Syscall Journey">Syscall Journey<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.124.1"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.2"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
