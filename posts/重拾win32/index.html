<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>重拾Win32 - Ghostasky's Blog</title><meta name=author content>
<meta name=author-link content><meta name=description content><meta name=keywords content><meta itemprop=name content="重拾Win32"><meta itemprop=description content><meta itemprop=datePublished content="2022-04-01T00:00:00+00:00"><meta itemprop=dateModified content="2022-04-01T00:00:00+00:00"><meta itemprop=wordCount content="15862"><meta itemprop=keywords content="[Win32],"><meta property="og:title" content="重拾Win32"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-04-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="重拾Win32"><meta name=twitter:description content><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/><link rel=prev href=http://ghostasky.github.io/posts/springmvc%E5%88%9D%E6%8E%A2/><link rel=next href=http://ghostasky.github.io/posts/2022-6-29-bypassavdynamics/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"重拾Win32","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/ghostasky.github.io\/posts\/%E9%87%8D%E6%8B%BEwin32\/"},"genre":"posts","keywords":"","wordcount":15862,"url":"http:\/\/ghostasky.github.io\/posts\/%E9%87%8D%E6%8B%BEwin32\/","datePublished":"2022-04-01T00:00:00+00:00","dateModified":"2022-04-01T00:00:00+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Ghostasky's Blog"><img loading=lazy src=/images/fixit.png alt="Ghostasky's Blog" data-title="Ghostasky's Blog" class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Ghostasky's Blog</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/about/>关于</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Ghostasky's Blog"><img loading=lazy src=/images/fixit.png alt=/images/fixit.png data-title=/images/fixit.png class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Ghostasky's Blog</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/about/>关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>重拾Win32</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
Anonymous</span></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/technology/ class=post-category title="分类 - Technology"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Technology</a></span></div><div class=post-meta-line><span title="发布于 2022-04-01 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2022-04-01>2022-04-01</time></span>&nbsp;<span title="15862 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 15900 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 32 分钟</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#字符编码>字符编码</a><ul><li><a href=#ascii>ASCII</a></li><li><a href=#ascii表的扩展>ASCII表的扩展</a></li><li><a href=#unicode>Unicode</a></li></ul></li><li><a href=#c语言中的宽字符>C语言中的宽字符</a></li><li><a href=#win32api中的宽字符>Win32API中的宽字符</a></li><li><a href=#进程的创建>进程的创建</a></li><li><a href=#创建进程>创建进程</a></li><li><a href=#句柄表>句柄表</a><ul><li><a href=#内核对象>内核对象</a></li><li><a href=#管理内核对象>管理内核对象</a></li><li><a href=#多进程共享一个内核对象>多进程共享一个内核对象</a></li><li><a href=#句柄是否可以被继承>句柄是否可以被继承</a></li><li><a href=#句柄是否允许被继承>句柄是否"允许"被继承</a></li></ul></li><li><a href=#进程相关api>进程相关API</a><ul><li><a href=#全局句柄表>全局句柄表</a></li><li><a href=#以挂起的形式创建进程>以挂起的形式创建进程</a></li><li><a href=#模块目录和工作目录>模块目录和工作目录</a></li><li><a href=#其他进程相关api>其他进程相关API</a></li></ul></li><li><a href=#创建线程>创建线程</a><ul><li><a href=#传参>传参</a></li></ul></li><li><a href=#线程控制>线程控制</a><ul><li><a href=#停止线程>停止线程</a></li><li><a href=#suspendthread>SuspendThread</a></li><li><a href=#等待线程结束>等待线程结束</a></li><li><a href=#获取设置线程上下文>获取设置线程上下文</a></li><li><a href=#getthreadcontext>GetThreadContext</a></li></ul></li><li><a href=#临界区>临界区</a><ul><li><a href=#线程锁>线程锁</a></li></ul></li><li><a href=#互斥体>互斥体</a><ul><li><a href=#互斥体和线程锁的区别>互斥体和线程锁的区别</a></li><li><a href=#互斥体防止多开>互斥体防止多开</a></li></ul></li><li><a href=#事件>事件</a><ul><li><a href=#通知类型>通知类型</a></li><li><a href=#线程同步>线程同步</a></li></ul></li><li><a href=#窗口>窗口</a></li><li><a href=#消息队列>消息队列</a></li><li><a href=#第一个windows程序>第一个Windows程序</a><ul><li><a href=#调试信息输出>调试信息输出</a></li></ul></li><li><a href=#消息类型>消息类型</a><ul><li><a href=#处理窗口关闭>处理窗口关闭</a></li><li><a href=#处理键盘按下>处理键盘按下</a></li></ul></li><li><a href=#子窗口>子窗口</a><ul><li><a href=#子窗口控件>子窗口控件</a></li></ul></li><li><a href=#虚拟内存与物理内存>虚拟内存与物理内存</a><ul><li><a href=#可使用的物理内存>可使用的物理内存</a></li><li><a href=#可识别的物理内存>可识别的物理内存</a></li></ul></li><li><a href=#私有内存的申请释放>私有内存的申请释放</a><ul><li><a href=#virtualalloc>VirtualAlloc</a></li></ul></li><li><a href=#共享内存的申请释放>共享内存的申请释放</a><ul><li><a href=#createfilemapping>CreateFileMapping</a></li></ul></li><li><a href=#文件系统未完成文件操作相关api未写>文件系统(未完成，文件操作相关API未写)</a><ul><li><a href=#卷相关api>卷相关API</a></li><li><a href=#获取卷信息>获取卷信息</a></li><li><a href=#目录相关api>目录相关API</a></li><li><a href=#创建目录>创建目录</a></li><li><a href=#删除目录>删除目录</a></li><li><a href=#修改目录名称>修改目录名称</a></li><li><a href=#获取程序当前目录>获取程序当前目录</a></li><li><a href=#设置程序当前目录>设置程序当前目录</a></li><li><a href=#文件相关api>文件相关API</a></li><li><a href=#创建文件>创建文件</a></li><li><a href=#关闭文件>关闭文件</a></li></ul></li><li><a href=#内存映射文件>内存映射文件</a><ul><li><a href=#内存映射文件读写>内存映射文件读写</a></li><li><a href=#内存映射文件之共享>内存映射文件之共享</a></li><li><a href=#内存映射文件之写拷贝>内存映射文件之写拷贝</a></li></ul></li><li><a href=#静态链接库>静态链接库</a></li><li><a href=#动态链接库>动态链接库</a></li><li><a href=#隐式链接>隐式链接</a><ul><li><a href=#dllmain>DLLMain</a></li></ul></li><li><a href=#远程线程>远程线程</a><ul><li><a href=#createremotethread>CreateRemoteThread</a></li></ul></li><li><a href=#远程线程注入>远程线程注入</a><ul><li><a href=#什么是注入>什么是注入</a></li><li><a href=#远程线程注入的流程>远程线程注入的流程</a></li></ul></li><li><a href=#模块隐藏>模块隐藏</a><ul><li><a href=#模块隐藏-断链>模块隐藏-断链</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>之后想看看免杀和内核相关的东西，先把win32再看一遍吧，好多都忘了，还是滴水的课程，感谢海哥的课程！</p><p>[toc]</p><h2 id=介绍 class=heading-element><a href=#%e4%bb%8b%e7%bb%8d class=heading-mark></a>介绍</h2><p>Win32不是用来画界面的，如果你以后要在Windows写好程序，是必须要学Win32的；</p><h2 id=字符编码 class=heading-element><a href=#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81 class=heading-mark></a>字符编码</h2><h3 id=ascii class=heading-element><a href=#ascii class=heading-mark></a>ASCII</h3><p>使用指定的7 位二进制数组合来表示128种可能的字符。</p><p><img loading=lazy src=image-20220401175832925.png alt=image-20220401175832925.png srcset="image-20220401175832925.png?size=small, image-20220401175832925.png?size=medium 1.5x, image-20220401175832925.png?size=large 2x" data-title=image-20220401175832925.png style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>最大为<code>0x7F</code></p><h4 id=扩展ascii表 class=heading-element><a href=#%e6%89%a9%e5%b1%95ascii%e8%a1%a8 class=heading-mark></a>扩展ASCII表</h4><p>从<code>0x80</code> 到<code>0xFF</code>：（未截全）</p><p><img loading=lazy src=image-20220401180412423.png alt=image-20220401180412423 srcset="image-20220401180412423.png?size=small, image-20220401180412423.png?size=medium 1.5x, image-20220401180412423.png?size=large 2x" data-title=image-20220401180412423 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>对于中文韩文日文等还是不够。</p><h3 id=ascii表的扩展 class=heading-element><a href=#ascii%e8%a1%a8%e7%9a%84%e6%89%a9%e5%b1%95 class=heading-mark></a>ASCII表的扩展</h3><p>GB2312/GB2312-80，与GBK差不多的。</p><p>（GB2312标准共收录 6763个汉字，GBK共收入21886个汉字和图形符号）</p><p><img loading=lazy src=image-20220401181028760.png alt=image-20220401181028760 srcset="image-20220401181028760.png?size=small, image-20220401181028760.png?size=medium 1.5x, image-20220401181028760.png?size=large 2x" data-title=image-20220401181028760 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>每一个都是扩展ASCII。</p><p>假设我们将“中国”这两个字发给国外的朋友，他的电脑上并没有该编码表，所以解析出 来的则不会是汉字，而会出现大家所熟知的“乱码”</p><h3 id=unicode class=heading-element><a href=#unicode class=heading-mark></a>Unicode</h3><p>Unicode编码创建了一张包含世界上所有文字的编码表，只要世界上存在的文字符号，都会赋予 一个唯一的编码</p><p>Unicode编码的范围是：0x0-0x10FFFF，其可以容纳100多万个符号</p><h4 id=存储方式 class=heading-element><a href=#%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f class=heading-mark></a>存储方式</h4><h5 id=utf-16 class=heading-element><a href=#utf-16 class=heading-mark></a>UTF-16</h5><p>UTF-16/UTF-8是Unicode存储的实现方式；<strong>UTF-16编码是以16个无符号整数位单位</strong>，注意是16位为一个单位， 但不表示一个字符就只有16位，具体的要看字符的Unicode编码所在范围，有可能是2字节，有可能是4字节， <strong>现在机器上的Unicode编码一般指的就是UTF-16</strong>。</p><p>会有le与be两种，就是存储方式为大端序和小端序。</p><p>举例（假的）：</p><ul><li>中（Unicode编码）：0x1234</li><li>国（Unicode编码）：0x12345</li></ul><p>存储的时候，中占2字节，国占4字节（0x0001 2345）</p><p>如‘中’和‘A’的存储</p><p><img loading=lazy src=image-20220401182412900.png alt=image-20220401182412900 srcset="image-20220401182412900.png?size=small, image-20220401182412900.png?size=medium 1.5x, image-20220401182412900.png?size=large 2x" data-title=image-20220401182412900 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>比较浪费，于是有了utf8</p><h5 id=utf-8 class=heading-element><a href=#utf-8 class=heading-mark></a>UTF-8</h5><p>UTF-8称之为可<strong>变长存储</strong>方案，其存储根据字符大小来分配，例如字母A就分配一个字节，汉字“中”就分配两个 字节。</p><p>优点：节省空间；缺点：解析很麻烦</p><h5 id=bom class=heading-element><a href=#bom class=heading-mark></a>BOM</h5><p>BOM中文为字节顺序标记，其就是用来插入到文本文件起始位置开头的，用于识别Unicode文件的编码类型。</p><p>上面的截图，有<code>FFFE</code>之类的东西，那个就是。</p><table><thead><tr><th>utf8</th><th>EF EB BF</th></tr></thead><tbody><tr><td>UTF-16LE(LITTLE)</td><td>FF FE</td></tr><tr><td>UTF-16BE(BIG)</td><td>FE FF</td></tr></tbody></table><p><img loading=lazy src=image-20220401183005344.png alt=image-20220401183005344 srcset="image-20220401183005344.png?size=small, image-20220401183005344.png?size=medium 1.5x, image-20220401183005344.png?size=large 2x" data-title=image-20220401183005344 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=c语言中的宽字符 class=heading-element><a href=#c%e8%af%ad%e8%a8%80%e4%b8%ad%e7%9a%84%e5%ae%bd%e5%ad%97%e7%ac%a6 class=heading-mark></a>C语言中的宽字符</h2><div class=highlight id=id-1><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ASCII码</span><span class=err>：</span><span class=kt>char</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;中国&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Unicode编码</span><span class=err>（</span><span class=n>UTF</span><span class=o>-</span><span class=mi>16</span><span class=err>）：</span><span class=kt>wchar_t</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;中国&#34;</span></span></span></code></pre></div><p>字符串长度：</p><div class=highlight id=id-2><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;China&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>wchar_t</span> <span class=n>strBuff1</span><span class=p>[]</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;China&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>strlen</span><span class=p>(</span><span class=n>strBuff</span><span class=p>);</span> <span class=c1>//取得多字节字符串中字符长度，不包含 00
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>wcslen</span><span class=p>(</span><span class=n>strBuff1</span><span class=p>);</span> <span class=c1>//取得多字节字符串中字符长度，不包含 00 00
</span></span></span></code></pre></div><div class=highlight id=id-3><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include&lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;locale.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>using</span> <span class=n>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>setlocale</span><span class=p>(</span><span class=n>LC_ALL</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>);</span><span class=c1>//使用控制台默认编码
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>wchar_t</span> <span class=n>wct</span><span class=p>[]</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;中国&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>wprintf</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>wct</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=win32api中的宽字符 class=heading-element><a href=#win32api%e4%b8%ad%e7%9a%84%e5%ae%bd%e5%ad%97%e7%ac%a6 class=heading-mark></a>Win32API中的宽字符</h2><p>主要存放在<code>C:\Windows\System32</code> （存储的DLL是64位）、<code>C:\Windows\SysWOW64</code>（存储的DLL是32位）下面的所有DLL文件（几千个），没写反，就是反的，32和64，qwq。 重要的DLL文件：</p><ul><li>Kernel32.dll：最核心的功能模块，例如内存管理、进程线程相关的函数等；</li><li>User32.dll：Windows用户界面相关的应用程序接口，例如创建窗口、发送信息等；</li><li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。</li></ul><p><img loading=lazy src=image-20220401185234453.png alt=image-20220401185234453 srcset="image-20220401185234453.png?size=small, image-20220401185234453.png?size=medium 1.5x, image-20220401185234453.png?size=large 2x" data-title=image-20220401185234453 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>win32使用字符串</p><p>字符串</p><div class=highlight id=id-4><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>CHAR</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;中国&#34;</span><span class=p>;</span> <span class=c1>// char
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>WCHAR</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;中国&#34;</span><span class=p>;</span> <span class=c1>// wchar_t
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>TCHAR</span> <span class=n>strBuff</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;中国&#34;</span><span class=p>);</span> <span class=c1>// TCHAR 根据当前项目的编码自动选择char还是wchar_t，在Win32中推荐使用这种方式
</span></span></span></code></pre></div><p>指针</p><div class=highlight id=id-5><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>PSTR</span> <span class=n>strPoint</span> <span class=o>=</span> <span class=s>&#34;中国&#34;</span><span class=p>;</span> <span class=c1>// char*
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>PWSTR</span> <span class=n>strPoint</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;中国&#34;</span><span class=p>;</span> <span class=c1>// wchar_t*
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>PTSTR</span> <span class=n>strPoint</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;中国&#34;</span><span class=p>);</span> <span class=c1>// PTSTR 根据当前项目的编码自动选择如char*还是wchar_t*，在Win32中推荐使用这种方式
</span></span></span></code></pre></div><h2 id=进程的创建 class=heading-element><a href=#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba class=heading-mark></a>进程的创建</h2><p>程序所需要的资源（数据、代码&mldr;）是由进程提供的；进程是一种空间上的概念，它的责任就是提供资源，至于资源如何使用，与它无关。</p><p><img loading=lazy src=image-20220401190727181.png alt=image-20220401190727181 srcset="image-20220401190727181.png?size=small, image-20220401190727181.png?size=medium 1.5x, image-20220401190727181.png?size=large 2x" data-title=image-20220401190727181 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>当我们在Windows下双击打开一个文件，实际上就是<code>explore.exe</code>这个进程创建的我们打开文件的进程，其使用的方法就是：CreateProcess()</p><p>进程创建的过程也就是<strong>CreateProcess函数</strong>：</p><pre tabindex=0><code>1.  映射EXE文件（低2G）
2.  创建内核对象EPROCESS（高2G）(每个进程都有一个)
3.  映射系统DLL（ntdll.dll）（放到用户区）
4.  创建线程内核对象RTHREAD（高2G）(每个进程都有一个)
5.  系统启动线程：
    1.  映射DLL（ntdll.LdrInitializeThunk）
    2.  线程开始执行</code></pre><h2 id=创建进程 class=heading-element><a href=#%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b class=heading-mark></a>创建进程</h2><p>CreateProcess：</p><div class=highlight id=id-7><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>CreateProcess</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>LPCTSTR</span> <span class=n>lpApplicationName</span><span class=p>,</span>                 <span class=c1>// name of executable module 进程名（完整文件路径）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPTSTR</span> <span class=n>lpCommandLine</span><span class=p>,</span>                      <span class=c1>// command line string 命令行传参
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpProcessAttributes</span><span class=p>,</span> <span class=c1>// SD 进程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpThreadAttributes</span><span class=p>,</span>  <span class=c1>// SD 线程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BOOL</span> <span class=n>bInheritHandles</span><span class=p>,</span>                      <span class=c1>// handle inheritance option 句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>dwCreationFlags</span><span class=p>,</span>                     <span class=c1>// creation flags 标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPVOID</span> <span class=n>lpEnvironment</span><span class=p>,</span>                      <span class=c1>// new environment block 父进程环境变量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPCTSTR</span> <span class=n>lpCurrentDirectory</span><span class=p>,</span>                <span class=c1>// current directory name 父进程目录作为当前目录，设置目录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPSTARTUPINFO</span> <span class=n>lpStartupInfo</span><span class=p>,</span>               <span class=c1>// startup information 结构体详细信息（启动进程相关信息）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>LPPROCESS_INFORMATION</span> <span class=n>lpProcessInformation</span> <span class=c1>// process information 结构体详细信息（进程ID、线程ID、进程句柄、线程句柄）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>其中的倒数第一二个参数是结构体，</p><div class=highlight id=id-8><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_STARTUPINFOA</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>cb</span><span class=p>;</span><span class=c1>//The size of the structure, in bytes.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSTR</span>  <span class=n>lpReserved</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>LPSTR</span>  <span class=n>lpDesktop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>LPSTR</span>  <span class=n>lpTitle</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwXSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwYSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwXCountChars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwYCountChars</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwFillAttribute</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwFlags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>   <span class=n>wShowWindow</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>WORD</span>   <span class=n>cbReserved2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>LPBYTE</span> <span class=n>lpReserved2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hStdInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hStdOutput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hStdError</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>STARTUPINFOA</span><span class=p>,</span> <span class=o>*</span><span class=n>LPSTARTUPINFOA</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_PROCESS_INFORMATION</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwProcessId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>dwThreadId</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>PROCESS_INFORMATION</span><span class=p>,</span> <span class=o>*</span><span class=n>PPROCESS_INFORMATION</span><span class=p>,</span> <span class=o>*</span><span class=n>LPPROCESS_INFORMATION</span><span class=p>;</span></span></span></code></pre></div><p>不用管，直接写0就行，而且也差不多可以看懂</p><div class=highlight id=id-9><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>TCHAR</span> <span class=n>childProcessName</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;C:/WINDOWS/system32/cmd.exe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>TCHAR</span> <span class=n>childPeocessCmd</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;/c ping www.baidu.com&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>STARTUPINFO</span> <span class=n>si</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PROCESS_INFORMATION</span> <span class=n>pi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=nf>ZeroMemory</span><span class=p>(</span><span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>si</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=nf>ZeroMemory</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pi</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pi</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>CreateProcess</span><span class=p>(</span><span class=n>childProcessName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>childPeocessCmd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>FALSE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;create success</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;CreateProcess Error: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span><span class=c1>//使用getlasterror获取错误信息
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>CloseHandle</span><span class=p>(</span><span class=n>pi</span><span class=p>.</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>CloseHandle</span><span class=p>(</span><span class=n>pi</span><span class=p>.</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=句柄表 class=heading-element><a href=#%e5%8f%a5%e6%9f%84%e8%a1%a8 class=heading-mark></a>句柄表</h2><h3 id=内核对象 class=heading-element><a href=#%e5%86%85%e6%a0%b8%e5%af%b9%e8%b1%a1 class=heading-mark></a>内核对象</h3><p>例如进程、线程、文件、互斥体、事件等等在内核都有一个对应的结构体，这些结构体都由内核负责管理，所以我们都可以称之为内核对象。</p><p><strong>CloseHandle</strong>这个API可以关的都是内核对象</p><p><img loading=lazy src=image-20220401222824870.png alt=image-20220401222824870 srcset="image-20220401222824870.png?size=small, image-20220401222824870.png?size=medium 1.5x, image-20220401222824870.png?size=large 2x" data-title=image-20220401222824870 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h3 id=管理内核对象 class=heading-element><a href=#%e7%ae%a1%e7%90%86%e5%86%85%e6%a0%b8%e5%af%b9%e8%b1%a1 class=heading-mark></a>管理内核对象</h3><p>当我们使用如下图所示的函数创建时，会在内核层创建一个结构体，而我们该如何管理这些结构体呢？或者说如何使用这些结构体呢？其实很好解决，我们可以通过内核结构体地址来管理，但是这样做存在问题：<strong>应用层很有可能操作不当导致修改啦内核结构体的地址</strong>，我们写应用层代码都知道访问到一个不存在的内存地址就会报错，而如果访问到一个内核地址是错误的，微软系统下则直接会蓝屏。</p><p><img loading=lazy src=image-20220401222934940.png alt=image-20220401222934940 srcset="image-20220401222934940.png?size=small, image-20220401222934940.png?size=medium 1.5x, image-20220401222934940.png?size=large 2x" data-title=image-20220401222934940 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>这个时候句柄表出现了。</p><p>只有进程才会有句柄表，并且<strong>每一个进程都会有一个句柄表</strong>。</p><p><img loading=lazy src=image-20220401223201318.png alt=image-20220401223201318 srcset="image-20220401223201318.png?size=small, image-20220401223201318.png?size=medium 1.5x, image-20220401223201318.png?size=large 2x" data-title=image-20220401223201318 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>句柄本质上就一个防火墙，将应用层、内核层隔离开来，通过句柄就可以控制进程内核结构体，我们得到所谓句柄的值实际上就是句柄表里的一个索引。</p><h3 id=多进程共享一个内核对象 class=heading-element><a href=#%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%85%b1%e4%ba%ab%e4%b8%80%e4%b8%aa%e5%86%85%e6%a0%b8%e5%af%b9%e8%b1%a1 class=heading-mark></a>多进程共享一个内核对象</h3><p>A进程通过<strong>CreateProcess函数</strong>创建了一个内核对象；B进程通过<strong>OpenProcess函数</strong>可以打开别人创建好的一个进程，也就是可以操作其的内核对象；A进程想要操作内核对象就通过其对应的句柄表的句柄（索引）来操作；B进程操作这个内核对象也是通过它自己的句柄表的句柄（索引）来操作内核对象。（需要注意的是：句柄表是一个私有的，句柄值就是进程自己句柄表的索引）</p><p><img loading=lazy src=image-20220401231930158.png alt=image-20220401231930158 srcset="image-20220401231930158.png?size=small, image-20220401231930158.png?size=medium 1.5x, image-20220401231930158.png?size=large 2x" data-title=image-20220401231930158 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>在之前的例子中我们提到了CloseHandle这个函数是用来关闭进程、线程的，其实它的本质就是释放句柄，但是并不代表执行了这个函数，创建的内核对象就会<strong>彻底消失</strong>；如上图中所示内核对象存在一个计数器，目前是2，它的值是根据调用A的次数来决定的，如果我们只是在A进程中执行了<strong>CloseHandle函数</strong>，内核对象并不会消失，因为进程B还在使用，而只有进程B也执行了<strong>CloseHandle函数</strong>，这个内核对象的计数器为0，就会关闭消失了</p><p><strong>最后</strong>：注意，以上所述特性适合于<strong>除了线程</strong>以外的所有内核对象，创建进程，同时也会创建线程，如果你想把线程关闭，首先需要<strong>CloseHandle函数</strong>要让其计数器为0，其次需要有人将其关闭，所以假设我们创建了一个IE进程打开了一个网站，如果我们只是在代码中使用了<strong>CloseHandle函数</strong>，这样IE浏览器并不会关闭，需要我们手动点击窗口的关闭按钮才行（<strong>只有线程关闭了，进程才会关闭</strong>）。</p><h3 id=句柄是否可以被继承 class=heading-element><a href=#%e5%8f%a5%e6%9f%84%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e8%a2%ab%e7%bb%a7%e6%89%bf class=heading-mark></a>句柄是否可以被继承</h3><p>除了我们上述的方式可以进行共享内核对象以外，Windows还设计了一种方式来提供我们共享内核对象，我们先来了解一下句柄是否"可以"被继承。</p><p>如下图所示（<strong>句柄表是有三列的，分别是句柄值、内核结构体地址、句柄是否可以被继承</strong>），比如说我们在A进程（父进程）创建了4个内核对象：</p><p><img loading=lazy src=image-20220401233035405.png alt=image-20220401233035405 srcset="image-20220401233035405.png?size=small, image-20220401233035405.png?size=medium 1.5x, image-20220401233035405.png?size=large 2x" data-title=image-20220401233035405 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>这四个函数都有一个参数<strong>LPSECURITY_ATTRIBUTES lpThreadAttributes</strong>，通过这个参数我们可以判断函数是否创建的是内核对象。</p><p>比如拿CreateEvent来看：</p><div class=highlight id=id-10><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateEventA</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span> <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpEventAttributes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>           <span class=n>BOOL</span>                  <span class=n>bManualReset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>           <span class=n>BOOL</span>                  <span class=n>bInitialState</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span> <span class=n>LPCSTR</span>                <span class=n>lpName</span>
</span></span><span class=line><span class=cl><span class=p>);</span></span></span></code></pre></div><p>它的第一个参数，其实就是一个结构体：</p><div class=highlight id=id-11><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_SECURITY_ATTRIBUTES</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>nLength</span><span class=p>;</span><span class=c1>//长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPVOID</span> <span class=n>lpSecurityDescriptor</span><span class=p>;</span><span class=c1>//安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span>   <span class=n>bInheritHandle</span><span class=p>;</span><span class=c1>//句柄是否被继承，这个是重点被关注的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>SECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>PSECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>LPSECURITY_ATTRIBUTES</span><span class=p>;</span></span></span></code></pre></div><p>这里使用CreateProcess来看：</p><div class=highlight id=id-12><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>CreateProcessA</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span>      <span class=n>LPCSTR</span>                <span class=n>lpApplicationName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>out</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span> <span class=n>LPSTR</span>                 <span class=n>lpCommandLine</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span>      <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpProcessAttributes</span><span class=p>,</span><span class=c1>//SD
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span>      <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpThreadAttributes</span><span class=p>,</span><span class=c1>//SD
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>                <span class=n>BOOL</span>                  <span class=n>bInheritHandles</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>                <span class=n>DWORD</span>                 <span class=n>dwCreationFlags</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span>      <span class=n>LPVOID</span>                <span class=n>lpEnvironment</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>,</span> <span class=n>optional</span><span class=p>]</span>      <span class=n>LPCSTR</span>                <span class=n>lpCurrentDirectory</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>in</span><span class=p>]</span>                <span class=n>LPSTARTUPINFOA</span>        <span class=n>lpStartupInfo</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=p>[</span><span class=n>out</span><span class=p>]</span>               <span class=n>LPPROCESS_INFORMATION</span> <span class=n>lpProcessInformation</span>
</span></span><span class=line><span class=cl><span class=p>);</span></span></span></code></pre></div><p>有两个LPSECURITY_ATTRIBUTES结构体，一个是进程的，一个是线程的：</p><div class=highlight id=id-13><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//这种是不被继承
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>CreateProcess</span><span class=p>(</span><span class=n>childProcessName</span><span class=p>,</span><span class=n>childPeocessCmd</span><span class=p>,</span><span class=nb>NULL</span><span class=p>,</span><span class=nb>NULL</span><span class=p>,</span><span class=n>FALSE</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//进程句柄，线程句柄都可以被继承
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SECURITY_ATTRIBUTES</span> <span class=n>sa</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>ZeroMemory</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>sa</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>sa</span><span class=p>.</span><span class=n>nLength</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>SECURITY_ATTRIBUTES</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>sa</span><span class=p>.</span><span class=n>bInheritHandle</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>CreateProcess</span><span class=p>(</span><span class=n>childProcessName</span><span class=p>,</span><span class=n>childPeocessCmd</span><span class=p>,</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span><span class=o>&amp;</span><span class=n>sa</span><span class=p>,</span><span class=n>FALSE</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>);</span></span></span></code></pre></div><h3 id=句柄是否允许被继承 class=heading-element><a href=#%e5%8f%a5%e6%9f%84%e6%98%af%e5%90%a6%e5%85%81%e8%ae%b8%e8%a2%ab%e7%bb%a7%e6%89%bf class=heading-mark></a>句柄是否"允许"被继承</h3><p>上面是说是否可以被继承，真正继承要另一个参数，还是CreateProcess举例，是<code>bInheritHandles</code>这个参数，这个参数决定了是否允许创建的子进程继承句柄，设置为TRUE时，我们创建的子进程才允许继承父进程的句柄。</p><p><img loading=lazy src=image-20220401234807835.png alt=image-20220401234807835 srcset="image-20220401234807835.png?size=small, image-20220401234807835.png?size=medium 1.5x, image-20220401234807835.png?size=large 2x" data-title=image-20220401234807835 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=进程相关api class=heading-element><a href=#%e8%bf%9b%e7%a8%8b%e7%9b%b8%e5%85%b3api class=heading-mark></a>进程相关API</h2><p>CreateProcess函数会给我们返回一个结构体，包含四个数据：进程编号（ID）、进程句柄、线程编号（ID）、线程句柄。</p><p>进程ID，通常我们称之为PID，任务管理器中的就是。</p><h3 id=全局句柄表 class=heading-element><a href=#%e5%85%a8%e5%b1%80%e5%8f%a5%e6%9f%84%e8%a1%a8 class=heading-mark></a>全局句柄表</h3><p>每个进程都有一份私有的句柄表，而操作系统也有一份句柄表，我们称之为全局句柄表，这张表里包含了所有正在运行的进程、线程</p><p>PID我们就可以理解为是全局句柄表中的一个索引，那么PID和句柄的区别就很容易看出来来了，<strong>PID是全局的，在任何进程中都有意义，都可以使用，而句柄则是局部的、私有的</strong>；PID是<strong>唯一的，绝对不可能出现重复的存在</strong>，但是当进程消失，那么这个PID就有可能会分给另外一个进程。（<strong>PID不是句柄，但是可以通过PID获得到全局句柄表中其对应的句柄</strong>）</p><p>A程序打开IE，获取PID和句柄：</p><div class=highlight id=id-14><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TCHAR</span> <span class=n>childProcessName</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;C:</span><span class=se>\\</span><span class=s>Program Files</span><span class=se>\\</span><span class=s>Internet Explorer</span><span class=se>\\</span><span class=s>iexplore.exe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>TCHAR</span> <span class=n>childPeocessCmd</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;http://www.baidu.com&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>STARTUPINFO</span> <span class=n>si</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PROCESS_INFORMATION</span> <span class=n>pi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>ZeroMemory</span><span class=p>(</span><span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>si</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>ZeroMemory</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pi</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>pi</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>CreateProcess</span><span class=p>(</span><span class=n>childProcessName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=n>childPeocessCmd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=n>FALSE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;create success</span><span class=se>\n</span><span class=s>PID:%d, 句柄:%d&#34;</span><span class=p>,</span> <span class=n>pi</span><span class=p>.</span><span class=n>dwProcessId</span><span class=p>,</span> <span class=n>pi</span><span class=p>.</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;CreateProcess Error: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>pi</span><span class=p>.</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>pi</span><span class=p>.</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>system</span><span class=p>(</span><span class=s>&#34;pause&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>之后B使用TerminateProcess函数来终止A进程：</p><div class=highlight id=id-15><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// TerminateProcess函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>TerminateProcess</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>,</span> <span class=c1>// handle to the process 句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>UINT</span> <span class=n>uExitCode</span>   <span class=c1>// exit code for the process 退出代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-16><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdlib.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hProcess</span> <span class=o>=</span> <span class=p>(</span><span class=n>HANDLE</span><span class=p>)</span><span class=mh>0x1b0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>TerminateProcess</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;终止失败,%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>可以看见是失败，6，句柄无效，真正的关闭这个进程，那就需要借助PID来获取句柄：</p><div class=highlight id=id-17><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>OpenProcess</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwDesiredAccess</span><span class=p>,</span>  <span class=c1>// access flag 你希望的访问权限,https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bInheritHandle</span><span class=p>,</span>    <span class=c1>// handle inheritance option 是否可以被继承
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwProcessId</span>       <span class=c1>// process identifier 进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-18><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hProcess</span> <span class=o>=</span> <span class=nf>OpenProcess</span><span class=p>(</span><span class=n>PROCESS_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=mh>0x4598</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>TerminateProcess</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;终止进程失败：%d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>运行之后发现iE关了。</p><h3 id=以挂起的形式创建进程 class=heading-element><a href=#%e4%bb%a5%e6%8c%82%e8%b5%b7%e7%9a%84%e5%bd%a2%e5%bc%8f%e5%88%9b%e5%bb%ba%e8%bf%9b%e7%a8%8b class=heading-mark></a>以挂起的形式创建进程</h3><p>还是CreateProcess，第六个参数</p><div class=highlight id=id-19><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>CreateProcess</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpApplicationName</span><span class=p>,</span>                 <span class=c1>// name of executable module
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTSTR</span> <span class=n>lpCommandLine</span><span class=p>,</span>                      <span class=c1>// command line string
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpProcessAttributes</span><span class=p>,</span> <span class=c1>// SD
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpThreadAttributes</span><span class=p>,</span>  <span class=c1>// SD
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bInheritHandles</span><span class=p>,</span>                      <span class=c1>// handle inheritance option
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwCreationFlags</span><span class=p>,</span>                     <span class=c1>// creation flags &lt;--这个参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPVOID</span> <span class=n>lpEnvironment</span><span class=p>,</span>                      <span class=c1>// new environment block
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCTSTR</span> <span class=n>lpCurrentDirectory</span><span class=p>,</span>                <span class=c1>// current directory name
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSTARTUPINFO</span> <span class=n>lpStartupInfo</span><span class=p>,</span>               <span class=c1>// startup information
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPPROCESS_INFORMATION</span> <span class=n>lpProcessInformation</span> <span class=c1>// process information
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-20><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TCHAR</span> <span class=n>childProcessName</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;C:/WINDOWS/system32/cmd.exe&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>TCHAR</span> <span class=n>childPeocessCmd</span><span class=p>[]</span> <span class=o>=</span> <span class=nf>TEXT</span><span class=p>(</span><span class=s>&#34;/c ping www.baidu.com&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nf>CreateProcess</span><span class=p>(</span><span class=n>childProcessName</span><span class=p>,</span><span class=n>childPeocessCmd</span><span class=p>,</span>  <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span><span class=n>CREATE_NEW_CONSOLE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>pi</span><span class=p>)</span></span></span></code></pre></div><p>写<code>CREATE_NEW_CONSOLE</code>就会在新的终端打开，不然就是本终端打开。</p><p>但是我们关注的是另一个，有意义的，<code>CREATE_SUSPENDED</code></p><p><img loading=lazy src=image2021-5-22_1-12-9.png alt=image2021-5-22_1-12-9.png srcset="image2021-5-22_1-12-9.png?size=small, image2021-5-22_1-12-9.png?size=medium 1.5x, image2021-5-22_1-12-9.png?size=large 2x" data-title=image2021-5-22_1-12-9.png style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>释放使用resumeThread</p><h3 id=模块目录和工作目录 class=heading-element><a href=#%e6%a8%a1%e5%9d%97%e7%9b%ae%e5%bd%95%e5%92%8c%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95 class=heading-mark></a>模块目录和工作目录</h3><div class=highlight id=id-21><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>strModule</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetModuleFileName</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,(</span><span class=n>LPWSTR</span><span class=p>)</span><span class=n>strModule</span><span class=p>,</span> <span class=mi>256</span><span class=p>);</span><span class=c1>// 得到当前模块目录，当前exe所在的路径，包含exe文件名
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>strWork</span><span class=p>[</span><span class=mi>1000</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetCurrentDirectory</span><span class=p>(</span><span class=mi>1000</span><span class=p>,</span> <span class=p>(</span><span class=n>LPWSTR</span><span class=p>)</span><span class=n>strWork</span><span class=p>);</span> <span class=c1>// 获取当前工作目录
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;模块目录：%ws </span><span class=se>\n</span><span class=s>工作目录：%ws </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>strModule</span><span class=p>,</span> <span class=n>strWork</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=其他进程相关api class=heading-element><a href=#%e5%85%b6%e4%bb%96%e8%bf%9b%e7%a8%8b%e7%9b%b8%e5%85%b3api class=heading-mark></a>其他进程相关API</h3><p>获取当前进程ID（PID）：GetCurrentProcessId</p><p>获取当前进程句柄：GetCurrentProcess</p><p>获取命令行：GetCommandLine</p><p>获取启动信息：GetStartupInfo</p><p>遍历进程ID：EnumProcesses</p><p>快照：CreateToolhelp32Snapshot</p><h2 id=创建线程 class=heading-element><a href=#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b class=heading-mark></a>创建线程</h2><p>线程：附属在进程上的执行实体，</p><div class=highlight id=id-22><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateThread</span><span class=p>(</span> <span class=c1>// 返回值是线程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpThreadAttributes</span><span class=p>,</span> <span class=c1>// SD 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SIZE_T</span> <span class=n>dwStackSize</span><span class=p>,</span>                       <span class=c1>// initial stack size 初始堆栈
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTHREAD_START_ROUTINE</span> <span class=n>lpStartAddress</span><span class=p>,</span>    <span class=c1>// thread function 线程执行的函数代码
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>,</span>                       <span class=c1>// thread argument 线程需要的参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwCreationFlags</span><span class=p>,</span>                    <span class=c1>// creation option 标识，也可以以挂起形式创建线程
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpThreadId</span>                        <span class=c1>// thread identifier 返回当前线程ID
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-23><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include&lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 线程执行的函数有语法要求，参考MSDN Library
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 要执行的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Sleep</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;++++++ %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hd</span><span class=o>=</span><span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 要执行的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Sleep</span><span class=p>(</span><span class=mi>500</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;------ %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=传参 class=heading-element><a href=#%e4%bc%a0%e5%8f%82 class=heading-mark></a>传参</h3><div class=highlight id=id-24><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 要执行的代码
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=n>lpParameter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>....................</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>.............</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span><span class=o>=</span><span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hd</span><span class=o>=</span><span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>..........</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=线程控制 class=heading-element><a href=#%e7%ba%bf%e7%a8%8b%e6%8e%a7%e5%88%b6 class=heading-mark></a>线程控制</h2><h3 id=停止线程 class=heading-element><a href=#%e5%81%9c%e6%ad%a2%e7%ba%bf%e7%a8%8b class=heading-mark></a>停止线程</h3><p>停止自己的线程，可以使用sleep函数，上面有。</p><p>下面是停止别的线程：</p><h3 id=suspendthread class=heading-element><a href=#suspendthread class=heading-mark></a>SuspendThread</h3><p>SuspendThread函数用于暂停（挂起）某个线程，当暂停后该线程不会占用CPU，只需要传入一个线程句柄：</p><div class=highlight id=id-25><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>SuspendThread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hThread</span>   <span class=c1>// handle to thread
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-26><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=n>hd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>hd</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>SuspendThread</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>Sleep</span><span class=p>(</span><span class=mi>3000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>ResumeThread</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span></span></span></code></pre></div><h3 id=等待线程结束 class=heading-element><a href=#%e7%ad%89%e5%be%85%e7%ba%bf%e7%a8%8b%e7%bb%93%e6%9d%9f class=heading-mark></a>等待线程结束</h3><h4 id=waitforsingleobject class=heading-element><a href=#waitforsingleobject class=heading-mark></a>WaitForSingleObject</h4><p>WaitForSingleObject函数用于等待<strong>一个内核对象</strong>状态发生变更</p><div class=highlight id=id-27><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>WaitForSingleObject</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hHandle</span><span class=p>,</span>       
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwMilliseconds</span>   <span class=c1>// time-out interval 等待超时时间（毫秒）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p><code>INFINITE</code>表示，不指定超时时间，要执行完才继续走</p><div class=highlight id=id-28><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hd</span><span class=o>=</span><span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>hd</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>SuspendThread</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;end</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div><h4 id=waitformultipleobjects class=heading-element><a href=#waitformultipleobjects class=heading-mark></a>WaitForMultipleObjects</h4><div class=highlight id=id-29><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>WaitForMultipleObjects</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>nCount</span><span class=p>,</span>             <span class=c1>// number of handles in array 内核对象的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>CONST</span> <span class=n>HANDLE</span> <span class=o>*</span><span class=n>lpHandles</span><span class=p>,</span>  <span class=c1>// object-handle array 内核对象的句柄数组
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bWaitAll</span><span class=p>,</span>            <span class=c1>// wait option 等待模式
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwMilliseconds</span>      <span class=c1>// time-out interval 等待超时时间（毫秒）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-30><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>hd</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>WaitForMultipleObjects</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>hd</span><span class=p>,</span><span class=nb>true</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>SuspendThread</span><span class=p>(</span><span class=n>hd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;end</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span></span></span></code></pre></div><h4 id=getexitcodethread class=heading-element><a href=#getexitcodethread class=heading-mark></a>GetExitCodeThread</h4><p>和名字一样，</p><div class=highlight id=id-31><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>GetExitCodeThread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>,</span>      <span class=c1>// handle to the thread
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpExitCode</span>   <span class=c1>// termination status
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=获取设置线程上下文 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e8%ae%be%e7%bd%ae%e7%ba%bf%e7%a8%8b%e4%b8%8a%e4%b8%8b%e6%96%87 class=heading-mark></a>获取设置线程上下文</h3><h3 id=getthreadcontext class=heading-element><a href=#getthreadcontext class=heading-mark></a>GetThreadContext</h3><div class=highlight id=id-32><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>GetThreadContext</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>,</span>       <span class=c1>// handle to thread with context 句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCONTEXT</span> <span class=n>lpContext</span>   <span class=c1>// context structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-33><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=cm>/* hd[1] = CreateThread(NULL, NULL, ThreadProc1, NULL, 0, NULL);*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>SuspendThread</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CONTEXT</span> <span class=n>context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>.</span><span class=n>ContextFlags</span> <span class=o>=</span> <span class=n>CONTEXT_INTEGER</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetThreadContext</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;end</span><span class=se>\n</span><span class=s>%d ,%d&#34;</span><span class=p>,</span><span class=n>context</span><span class=p>.</span><span class=n>Rax</span><span class=p>,</span><span class=n>context</span><span class=p>.</span><span class=n>Rbx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>ResumeThread</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span></span></span></code></pre></div><h4 id=setthreadcontext class=heading-element><a href=#setthreadcontext class=heading-mark></a>SetThreadContext</h4><p>修改线程上下文</p><div class=highlight id=id-34><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>SetThreadContext</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>,</span>            <span class=c1>// handle to thread
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>CONST</span> <span class=n>CONTEXT</span> <span class=o>*</span><span class=n>lpContext</span>   <span class=c1>// context structure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-35><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>    <span class=n>CONTEXT</span> <span class=n>context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>.</span><span class=n>ContextFlags</span> <span class=o>=</span> <span class=n>CONTEXT_INTEGER</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>.</span><span class=n>Eax</span> <span class=o>=</span> <span class=mh>0x123</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>SetThreadContext</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CONTEXT</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=p>.</span><span class=n>ContextFlags</span> <span class=o>=</span> <span class=n>CONTEXT_INTEGER</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>GetThreadContext</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%x ,%x&#34;</span><span class=p>,</span> <span class=n>c</span><span class=p>.</span><span class=n>Eax</span><span class=p>,</span> <span class=n>c</span><span class=p>.</span><span class=n>Ebp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>ResumeThread</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span></span></span></code></pre></div><h2 id=临界区 class=heading-element><a href=#%e4%b8%b4%e7%95%8c%e5%8c%ba class=heading-mark></a>临界区</h2><p>每个线程都有自己的栈，局部变量是存储在栈中的，这就意味着每个进程都会有一份自己的“句柄变量”（栈），如果线程仅仅使用自己的“局部变量”那就不存在线程安全问题，反之，如果多个线程共用一个全局变量，且修改该全局变量就会出现问题。</p><p>临界资源：一次只有一个线程使用</p><p>临界区：访问临界资源的代码</p><h3 id=线程锁 class=heading-element><a href=#%e7%ba%bf%e7%a8%8b%e9%94%81 class=heading-mark></a>线程锁</h3><p>使用线程锁来解决上面的问题。</p><div class=highlight id=id-36><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>创建全局变量：</span><span class=n>CRITICAL_SECTION</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=err>初始化全局变量：</span><span class=nf>InitializeCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=err>实现临界区：进入</span> <span class=err>→</span> <span class=nf>EnterCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span> <span class=err>离开</span> <span class=err>→</span> <span class=nf>LeaveCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span></span></span></code></pre></div><p>注意要init，找了半天错，，，，，</p><div class=highlight id=id-37><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include&lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>CRITICAL_SECTION</span> <span class=n>cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>tickNUM</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=nf>EnterCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tickNUM</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;现在有%d张 &#34;</span><span class=p>,</span> <span class=n>tickNUM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>tickNUM</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;还有%d 张</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>tickNUM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>LeaveCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>LeaveCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>InitializeCriticalSection</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hd</span><span class=p>,</span><span class=n>hd1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hd</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hd1</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//getchar();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=互斥体 class=heading-element><a href=#%e4%ba%92%e6%96%a5%e4%bd%93 class=heading-mark></a>互斥体</h2><p><strong>假设A进程的B线程和C进程的D线程</strong>，同时使用的是内核级的临界资源（<strong>内核对象：线程、文件、进程&mldr;</strong>）该怎么让这个访问是安全的？<strong>使用线程锁的方式明显不行，因为线程锁仅能控制同进程中的多线程</strong>。这个时候使用互斥体：</p><p><img loading=lazy src=image-20220404132056222.png alt=image-20220404132056222 srcset="image-20220404132056222.png?size=small, image-20220404132056222.png?size=medium 1.5x, image-20220404132056222.png?size=large 2x" data-title=image-20220404132056222 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><div class=highlight id=id-38><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateMutex</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpMutexAttributes</span><span class=p>,</span>  <span class=c1>// SD 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bInitialOwner</span><span class=p>,</span>                       <span class=c1>// initial owner 是否希望互斥体创建出来就有信号，或者说就可以使用，如果希望的话就为FALSE；官方解释为如果该值为TRUE则表示当前进程拥有该互斥体所有权
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCTSTR</span> <span class=n>lpName</span>                            <span class=c1>// object name 互斥体的名字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-39><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include&lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//想要创建出来就有信号，第二个参数给false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HANDLE</span> <span class=n>hs</span> <span class=o>=</span> <span class=nf>CreateMutex</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCWSTR</span><span class=p>)</span><span class=s>&#34;xyz&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>hs</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>Sleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>ReleaseMutex</span><span class=p>(</span><span class=n>hs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=互斥体和线程锁的区别 class=heading-element><a href=#%e4%ba%92%e6%96%a5%e4%bd%93%e5%92%8c%e7%ba%bf%e7%a8%8b%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab class=heading-mark></a>互斥体和线程锁的区别</h3><ol><li>线程锁只能用于单个进程间的线程控制</li><li>互斥体可以设定等待超时，但线程锁不能</li><li>线程意外结束时，互斥体可以避免无限等待</li><li>互斥体效率没有线程锁高</li></ol><h3 id=互斥体防止多开 class=heading-element><a href=#%e4%ba%92%e6%96%a5%e4%bd%93%e9%98%b2%e6%ad%a2%e5%a4%9a%e5%bc%80 class=heading-mark></a>互斥体防止多开</h3><p>防止多开，使用互斥体只是一个方法，<code>ERROR_ALREADY_EXISTS</code></p><div class=highlight id=id-40><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hs</span> <span class=o>=</span> <span class=nf>CreateMutex</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCWSTR</span><span class=p>)</span> <span class=s>&#34;防多开&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>GetLastError</span><span class=p>()</span> <span class=o>==</span> <span class=n>ERROR_ALREADY_EXISTS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;该程序已经开启了，请勿再次开启！&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>hs</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 操作资源
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Process: A Thread: B -- %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>Sleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=nf>ReleaseMutex</span><span class=p>(</span><span class=n>hs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=事件 class=heading-element><a href=#%e4%ba%8b%e4%bb%b6 class=heading-mark></a>事件</h2><p>事件本身也是一种内核对象，其也是是用来控制线程的。</p><h3 id=通知类型 class=heading-element><a href=#%e9%80%9a%e7%9f%a5%e7%b1%bb%e5%9e%8b class=heading-mark></a>通知类型</h3><div class=highlight id=id-41><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateEvent</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpEventAttributes</span><span class=p>,</span> <span class=c1>// SD 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bManualReset</span><span class=p>,</span>                       <span class=c1>// reset type 如果你希望当前事件类型是通知类型则写TRUE，反之FALSE
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>BOOL</span> <span class=n>bInitialState</span><span class=p>,</span>                      <span class=c1>// initial state 初始状态，决定创建出来时候是否有信号，有为TRUE，没有为FALSE
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCTSTR</span> <span class=n>lpName</span>                           <span class=c1>// object name 事件名字
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>互斥：只能有一个跑</p><p>通知：全部可以跑</p><div class=highlight id=id-42><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型
</span></span></span><span class=line><span class=cl><span class=c1>// 第三个参数表示初始状态没有信号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>e_event</span> <span class=o>=</span> <span class=nf>CreateEvent</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-43><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>HANDLE</span> <span class=n>e_event</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 等待事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>e_event</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;ThreadProc - running ...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProcB</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 等待事件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>e_event</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;ThreadProcB - running ...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 第二个参数，FALSE表示非通知类型通知，也就是互斥；TRUE则表示为通知类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 第三个参数表示初始状态没有信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>e_event</span> <span class=o>=</span> <span class=nf>CreateEvent</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建2个线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProcB</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//这里他并没有执行ThreadProc和ThreadProcB
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Sleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 设置事件为已通知，也就是设置为有信号，之后才跑
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>SetEvent</span><span class=p>(</span><span class=n>e_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 等待线程执行结束，销毁内核对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>WaitForMultipleObjects</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>hThread</span><span class=p>,</span> <span class=n>TRUE</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>e_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=线程同步 class=heading-element><a href=#%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5 class=heading-mark></a>线程同步</h3><p><strong>线程互斥</strong>：线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性；当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</p><p><strong>线程同步</strong>： 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒；同步的前提是互斥，其次就是有序，<strong>互斥并不代表A线程访问临界资源后就一定是B线程再去访问，也有可能是A线程，这就是属于无序的状态</strong>，所以同步就是<strong>互斥加上有序</strong>。</p><h4 id=使用互斥体实现 class=heading-element><a href=#%e4%bd%bf%e7%94%a8%e4%ba%92%e6%96%a5%e4%bd%93%e5%ae%9e%e7%8e%b0 class=heading-mark></a>使用互斥体实现</h4><p>会有很多cpu时间浪费掉：</p><div class=highlight id=id-44><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 容器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>container</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 次数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 互斥体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>HANDLE</span> <span class=n>hMutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 生产者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>container</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 等待互斥体，获取令牌
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>hMutex</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 获取当前进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>threadId</span> <span class=o>=</span> <span class=nf>GetCurrentThreadId</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 生产存放进容器
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>container</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;++Thread: %d, Build: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>threadId</span><span class=p>,</span> <span class=n>container</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;----------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>ReleaseMutex</span><span class=p>(</span><span class=n>hMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 消费者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProcB</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>container</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 等待互斥体，获取令牌
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>hMutex</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 获取当前进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>threadId</span> <span class=o>=</span> <span class=nf>GetCurrentThreadId</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;--Thread: %d, Consume: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>threadId</span><span class=p>,</span> <span class=n>container</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 消费
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>container</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;+++++++++++++++</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 释放令牌
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>ReleaseMutex</span><span class=p>(</span><span class=n>hMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建互斥体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hMutex</span> <span class=o>=</span> <span class=nf>CreateMutex</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建2个线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProcB</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>WaitForMultipleObjects</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>hThread</span><span class=p>,</span> <span class=n>TRUE</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><img loading=lazy src=image-20220404141649827.png alt=image-20220404141649827 srcset="image-20220404141649827.png?size=small, image-20220404141649827.png?size=medium 1.5x, image-20220404141649827.png?size=large 2x" data-title=image-20220404141649827 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>为了防止cpu时间的浪费，使用事件可以完美解决</p><h4 id=事件-1 class=heading-element><a href=#%e4%ba%8b%e4%bb%b6-1 class=heading-mark></a>事件</h4><div class=highlight id=id-45><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 容器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>container</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 次数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>HANDLE</span> <span class=n>eventa</span><span class=p>,</span> <span class=n>eventb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// 生产者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 等待互斥体，获取令牌
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>eventa</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取当前进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>threadId</span> <span class=o>=</span> <span class=nf>GetCurrentThreadId</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 生产存放进容器
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>container</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;++Thread: %d, Build: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>threadId</span><span class=p>,</span> <span class=n>container</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>SetEvent</span><span class=p>(</span><span class=n>eventb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 消费者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProcB</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 等待互斥体，获取令牌
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>WaitForSingleObject</span><span class=p>(</span><span class=n>eventb</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 获取当前进程ID
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>threadId</span> <span class=o>=</span> <span class=nf>GetCurrentThreadId</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>container</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;--Thread: %d, Consume: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>threadId</span><span class=p>,</span> <span class=n>container</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 消费
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=nf>SetEvent</span><span class=p>(</span><span class=n>eventa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>eventa</span> <span class=o>=</span> <span class=nf>CreateEvent</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>eventb</span> <span class=o>=</span> <span class=nf>CreateEvent</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建2个线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nf>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProcB</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>WaitForMultipleObjects</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>hThread</span><span class=p>,</span> <span class=n>TRUE</span><span class=p>,</span> <span class=n>INFINITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>eventa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>CloseHandle</span><span class=p>(</span><span class=n>eventb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><img loading=lazy src=image-20220404142455729.png alt=image-20220404142455729 srcset="image-20220404142455729.png?size=small, image-20220404142455729.png?size=medium 1.5x, image-20220404142455729.png?size=large 2x" data-title=image-20220404142455729 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=窗口 class=heading-element><a href=#%e7%aa%97%e5%8f%a3 class=heading-mark></a>窗口</h2><p>内核层也有模块：</p><p><img loading=lazy src=image-20220404142900172.png alt=image-20220404142900172 srcset="image-20220404142900172.png?size=small, image-20220404142900172.png?size=medium 1.5x, image-20220404142900172.png?size=large 2x" data-title=image-20220404142900172 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>Handle是私有的。</p><p>hwnd是全局的。</p><div class=highlight id=id-46><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include &lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HWND</span> <span class=n>hWnd</span><span class=p>;</span> <span class=c1>// 窗口句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HDC</span> <span class=n>hDc</span><span class=p>;</span>   <span class=c1>// 设备上下文对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HPEN</span> <span class=n>hPen</span><span class=p>;</span> <span class=c1>// 画笔
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 1. 设备对象，要绘画的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 设置为NULL则表示在桌面中绘画
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hWnd</span> <span class=o>=</span> <span class=p>(</span><span class=n>HWND</span><span class=p>)</span><span class=mh>0x000C058A</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 获取设备的上下文对象（DC）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>        HDC GetDC(
</span></span></span><span class=line><span class=cl><span class=cm>            HWND hWnd   // handle to window
</span></span></span><span class=line><span class=cl><span class=cm>        );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>hDc</span> <span class=o>=</span> <span class=n>GetDC</span><span class=p>(</span><span class=n>hWnd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 创建画笔，设置线条的属性
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>        HPEN CreatePen(
</span></span></span><span class=line><span class=cl><span class=cm>            int fnPenStyle,    // pen style
</span></span></span><span class=line><span class=cl><span class=cm>            int nWidth,        // pen width
</span></span></span><span class=line><span class=cl><span class=cm>            COLORREF crColor   // pen color
</span></span></span><span class=line><span class=cl><span class=cm>        );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>hPen</span> <span class=o>=</span> <span class=n>CreatePen</span><span class=p>(</span><span class=n>PS_SOLID</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>RGB</span><span class=p>(</span><span class=mh>0xFF</span><span class=p>,</span> <span class=mo>00</span><span class=p>,</span> <span class=mo>00</span><span class=p>));</span> <span class=c1>// RGB表示红绿蓝，红绿蓝的组合就可以组成新的一种颜色。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 关联
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>        HGDIOBJ SelectObject(
</span></span></span><span class=line><span class=cl><span class=cm>            HDC hdc,          // handle to DC
</span></span></span><span class=line><span class=cl><span class=cm>            HGDIOBJ hgdiobj   // handle to object
</span></span></span><span class=line><span class=cl><span class=cm>        );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>SelectObject</span><span class=p>(</span><span class=n>hDc</span><span class=p>,</span> <span class=n>hPen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 开始画线
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>        语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>        BOOL LineTo(
</span></span></span><span class=line><span class=cl><span class=cm>            HDC hdc,    // device context handle
</span></span></span><span class=line><span class=cl><span class=cm>            int nXEnd,  // x-coordinate of ending point
</span></span></span><span class=line><span class=cl><span class=cm>            int nYEnd   // y-coordinate of ending point
</span></span></span><span class=line><span class=cl><span class=cm>        );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>LineTo</span><span class=p>(</span><span class=n>hDc</span><span class=p>,</span> <span class=mi>400</span><span class=p>,</span> <span class=mi>400</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 释放资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DeleteObject</span><span class=p>(</span><span class=n>hPen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ReleaseDC</span><span class=p>(</span><span class=n>hWnd</span><span class=p>,</span> <span class=n>hDc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=消息队列 class=heading-element><a href=#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97 class=heading-mark></a>消息队列</h2><p>消息：当我们点击鼠标的时候，或者当我们按下键盘的时候，操作系统都要把这些动作记录下来，存储到一个结构体中，这个<strong>结构体</strong>就是消息。</p><p>消息队列：<strong>每个线程</strong>只有一个消息队列。</p><p><img loading=lazy src=image-20220404145930395.png alt=image-20220404145930395 srcset="image-20220404145930395.png?size=small, image-20220404145930395.png?size=medium 1.5x, image-20220404145930395.png?size=large 2x" data-title=image-20220404145930395 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=第一个windows程序 class=heading-element><a href=#%e7%ac%ac%e4%b8%80%e4%b8%aawindows%e7%a8%8b%e5%ba%8f class=heading-mark></a>第一个Windows程序</h2><div class=highlight id=id-47><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>WINAPI</span> <span class=nf>WinMain</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HINSTANCE</span> <span class=n>hInstance</span><span class=p>,</span>      <span class=c1>// handle to current instance,指向模块的句柄，实际上这个值就是模块在进程空间内的内存地址
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>HINSTANCE</span> <span class=n>hPrevInstance</span><span class=p>,</span>  <span class=c1>// handle to previous instance,该参数永远为空NULL，无需理解
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSTR</span> <span class=n>lpCmdLine</span><span class=p>,</span>          <span class=c1>// command line
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>int</span> <span class=n>nCmdShow</span>              <span class=c1>// show state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=调试信息输出 class=heading-element><a href=#%e8%b0%83%e8%af%95%e4%bf%a1%e6%81%af%e8%be%93%e5%87%ba class=heading-mark></a>调试信息输出</h3><p>不使用printf，使用OutputDebugString</p><pre tabindex=0><code>void OutputDebugString(
  LPCTSTR lpOutputString
);</code></pre><p><img loading=lazy src=image-20220404151609675.png alt=image-20220404151609675 srcset="image-20220404151609675.png?size=small, image-20220404151609675.png?size=medium 1.5x, image-20220404151609675.png?size=large 2x" data-title=image-20220404151609675 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><div class=highlight id=id-49><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>##include&lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// 窗口函数定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>LRESULT</span> <span class=n>CALLBACK</span> <span class=nf>WindowProc</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hwnd</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uMsg</span><span class=p>,</span> <span class=n>WPARAM</span> <span class=n>wParam</span><span class=p>,</span> <span class=n>LPARAM</span> <span class=n>lParam</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 必须要调用一个默认的消息处理函数，关闭、最小化、最大化都是由默认消息处理函数处理的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>DefWindowProc</span><span class=p>(</span><span class=n>hwnd</span><span class=p>,</span> <span class=n>uMsg</span><span class=p>,</span> <span class=n>wParam</span><span class=p>,</span> <span class=n>lParam</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>APIENTRY</span> <span class=nf>WinMain</span><span class=p>(</span><span class=n>HINSTANCE</span> <span class=n>hInstance</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>HINSTANCE</span> <span class=n>hPrevInstance</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LPSTR</span>     <span class=n>lpCmdLine</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>       <span class=n>nCmdShow</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>szOutBuff</span><span class=p>[</span><span class=mh>0x80</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 定义创建的窗口(创建注册窗口类)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>TCHAR</span> <span class=n>className</span><span class=p>[]</span> <span class=o>=</span> <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;My First Window&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>WNDCLASS</span> <span class=n>wndClass</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>0</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置窗口背景色
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wndClass</span><span class=p>.</span><span class=n>hbrBackground</span> <span class=o>=</span> <span class=p>(</span><span class=n>HBRUSH</span><span class=p>)</span><span class=n>COLOR_BACKGROUND</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置类名字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wndClass</span><span class=p>.</span><span class=n>lpszClassName</span> <span class=o>=</span> <span class=n>className</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置模块地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wndClass</span><span class=p>.</span><span class=n>hInstance</span> <span class=o>=</span> <span class=n>hInstance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理消息的窗口函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>wndClass</span><span class=p>.</span><span class=n>lpfnWndProc</span> <span class=o>=</span> <span class=n>WindowProc</span><span class=p>;</span> <span class=c1>// 不是调用函数，只是告诉操作系统，当前窗口对应的窗口回调函数是什么
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 注册窗口类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>RegisterClass</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wndClass</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 创建并显示窗口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 创建窗口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    CreateWindow 语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>    HWND CreateWindow(
</span></span></span><span class=line><span class=cl><span class=cm>        LPCTSTR lpClassName,  // registered class name 类名字
</span></span></span><span class=line><span class=cl><span class=cm>        LPCTSTR lpWindowName, // window name 窗口名字
</span></span></span><span class=line><span class=cl><span class=cm>        DWORD dwStyle,        // window style 窗口外观的样式
</span></span></span><span class=line><span class=cl><span class=cm>        int x,                // horizontal position of window 相对于父窗口x坐标
</span></span></span><span class=line><span class=cl><span class=cm>        int y,                // vertical position of window 相对于父窗口y坐标
</span></span></span><span class=line><span class=cl><span class=cm>        int nWidth,           // window width 窗口宽度：像素
</span></span></span><span class=line><span class=cl><span class=cm>        int nHeight,          // window height 窗口长度：像素
</span></span></span><span class=line><span class=cl><span class=cm>        HWND hWndParent,      // handle to parent or owner window 父窗口句柄
</span></span></span><span class=line><span class=cl><span class=cm>        HMENU hMenu,          // menu handle or child identifier 菜单句柄
</span></span></span><span class=line><span class=cl><span class=cm>        HINSTANCE hInstance,  // handle to application instance 模块
</span></span></span><span class=line><span class=cl><span class=cm>        LPVOID lpParam        // window-creation data  附加数据
</span></span></span><span class=line><span class=cl><span class=cm>    );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>HWND</span> <span class=n>hWnd</span> <span class=o>=</span> <span class=n>CreateWindow</span><span class=p>(</span><span class=n>className</span><span class=p>,</span> <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;窗口&#34;</span><span class=p>),</span> <span class=n>WS_OVERLAPPEDWINDOW</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>600</span><span class=p>,</span> <span class=mi>300</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>hInstance</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hWnd</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果为NULL则窗口创建失败，输出错误信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sprintf</span><span class=p>(</span><span class=n>szOutBuff</span><span class=p>,</span> <span class=s>&#34;Error: %d&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>((</span><span class=n>LPCWSTR</span><span class=p>)</span><span class=n>szOutBuff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 显示窗口
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    ShowWindow 语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>    BOOL ShowWindow(
</span></span></span><span class=line><span class=cl><span class=cm>        HWND hWnd,     // handle to window 窗口句柄
</span></span></span><span class=line><span class=cl><span class=cm>        int nCmdShow   // show state 显示的形式
</span></span></span><span class=line><span class=cl><span class=cm>    );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>ShowWindow</span><span class=p>(</span><span class=n>hWnd</span><span class=p>,</span> <span class=n>SW_SHOW</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 接收消息并处理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    GetMessage 语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>    BOOL GetMessage(
</span></span></span><span class=line><span class=cl><span class=cm>        LPMSG lpMsg,         // message information OUT类型参数，这是一个指针
</span></span></span><span class=line><span class=cl><span class=cm>        // 后三个参数都是过滤条件
</span></span></span><span class=line><span class=cl><span class=cm>        HWND hWnd,           // handle to window 窗口句柄，如果为NULL则表示该线程中的所有消息都要
</span></span></span><span class=line><span class=cl><span class=cm>        UINT wMsgFilterMin,  // first message 第一条信息
</span></span></span><span class=line><span class=cl><span class=cm>        UINT wMsgFilterMax   // last message 最后一条信息
</span></span></span><span class=line><span class=cl><span class=cm>    );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>MSG</span> <span class=n>msg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BOOL</span> <span class=n>bRet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>bRet</span> <span class=o>=</span> <span class=n>GetMessage</span><span class=p>(</span><span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>bRet</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// handle the error and possibly exit
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>sprintf</span><span class=p>(</span><span class=n>szOutBuff</span><span class=p>,</span> <span class=s>&#34;Error: %d&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>OutputDebugString</span><span class=p>((</span><span class=n>LPCWSTR</span><span class=p>)</span><span class=n>szOutBuff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 转换消息
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>TranslateMessage</span><span class=p>(</span><span class=o>&amp;</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 分发消息：就是给系统调用窗口处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>DispatchMessage</span><span class=p>(</span><span class=o>&amp;</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><img loading=lazy src=image-20220404153213749.png alt=image-20220404153213749 srcset="image-20220404153213749.png?size=small, image-20220404153213749.png?size=medium 1.5x, image-20220404153213749.png?size=large 2x" data-title=image-20220404153213749 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=消息类型 class=heading-element><a href=#%e6%b6%88%e6%81%af%e7%b1%bb%e5%9e%8b class=heading-mark></a>消息类型</h2><p>callback的几个参数，都是之前msg的部分参数</p><div class=highlight id=id-50><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>LRESULT</span> <span class=n>CALLBACK</span> <span class=nf>WindowProc</span><span class=p>(</span><span class=n>HWND</span> <span class=n>hwnd</span><span class=p>,</span> <span class=n>UINT</span> <span class=n>uMsg</span><span class=p>,</span> <span class=n>WPARAM</span> <span class=n>wParam</span><span class=p>,</span> <span class=n>LPARAM</span> <span class=n>lParam</span><span class=p>)</span> 
</span></span></code></pre></div><h3 id=处理窗口关闭 class=heading-element><a href=#%e5%a4%84%e7%90%86%e7%aa%97%e5%8f%a3%e5%85%b3%e9%97%ad class=heading-mark></a>处理窗口关闭</h3><div class=highlight id=id-51><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>case</span> <span class=nl>WM_DESTROY</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>PostQuitMessage</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div><h3 id=处理键盘按下 class=heading-element><a href=#%e5%a4%84%e7%90%86%e9%94%ae%e7%9b%98%e6%8c%89%e4%b8%8b class=heading-mark></a>处理键盘按下</h3><div class=highlight id=id-52><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>case</span> <span class=nl>WM_KEYDOWN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//MessageBox(0, 0, 0, 0)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sprintf</span><span class=p>(</span><span class=n>szOutBuff</span><span class=p>,</span> <span class=s>&#34;keyboard: %x - %x </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>uMsg</span><span class=p>,</span> <span class=n>wParam</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>((</span><span class=n>LPCTSTR</span><span class=p>)</span><span class=n>szOutBuff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>    
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>WM_CHAR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sprintf</span><span class=p>(</span><span class=n>szOutBuff</span><span class=p>,</span> <span class=s>&#34;字符: %c </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>wParam</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>((</span><span class=n>LPCTSTR</span><span class=p>)</span><span class=n>szOutBuff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div><p>所有的消息直接去查就行了，</p><p><img loading=lazy src=image-20220404162017477.png alt=image-20220404162017477 srcset="image-20220404162017477.png?size=small, image-20220404162017477.png?size=medium 1.5x, image-20220404162017477.png?size=large 2x" data-title=image-20220404162017477 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=子窗口 class=heading-element><a href=#%e5%ad%90%e7%aa%97%e5%8f%a3 class=heading-mark></a>子窗口</h2><h3 id=子窗口控件 class=heading-element><a href=#%e5%ad%90%e7%aa%97%e5%8f%a3%e6%8e%a7%e4%bb%b6 class=heading-mark></a>子窗口控件</h3><ol><li>Windows提供了几个预定义的窗口类以方便我们的使用，我们一般叫它们为子窗口控件，简称控件；</li><li>控件会自己处理消息，并在自己状态发生改变时通知父窗口；</li><li>预定义的控件有：按钮、复选框、编辑框、静态字符串标签和滚动条等。</li></ol><div class=highlight id=id-53><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##define CWA_EDIT 0x100
</span></span></span><span class=line><span class=cl><span class=cp>##define CWA_BUTTON_0 0x101
</span></span></span><span class=line><span class=cl><span class=cp>##define CWA_BUTTON_1 0x102
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// gHinstance = hInstance; 全局
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>case</span> <span class=nl>WM_CREATE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//编辑框
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CreateWindow</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;EDIT&#34;</span><span class=p>,</span>                                            <span class=c1>// registered class name 注册的类名，使用EDIT则为编辑框
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=s>&#34;&#34;</span><span class=p>,</span>                                                <span class=c1>// window name 窗口名称
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>WS_CHILD</span> <span class=o>|</span> <span class=n>WS_VISIBLE</span> <span class=o>|</span> <span class=n>WS_VSCROLL</span> <span class=o>|</span> <span class=n>ES_MULTILINE</span><span class=p>,</span> <span class=c1>// window style 子窗口控件样式：子窗口、创建后可以看到、滚动条、自动换行
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>0</span><span class=p>,</span>                                                 <span class=c1>// horizontal position of window 在父窗口上的x坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>0</span><span class=p>,</span>                                                 <span class=c1>// vertical position of window 在父窗口上的y坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>400</span><span class=p>,</span>                                               <span class=c1>// window width 控件宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>300</span><span class=p>,</span>                                               <span class=c1>// window height 控件高度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>hwnd</span><span class=p>,</span>                                              <span class=c1>// menu handle or child identifier 父窗口句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=n>HWND</span><span class=p>)</span><span class=n>CWA_EDIT</span><span class=p>,</span>                                    <span class=c1>// menu handle or child identifier 子窗口标识
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>gHinstance</span><span class=p>,</span>                                        <span class=c1>// handle to application instance 模块
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nb>NULL</span>                                               <span class=c1>// window-creation data 附加数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 创建&#34;设置&#34;按钮
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CreateWindow</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;BUTTON&#34;</span><span class=p>),</span>        <span class=c1>// registered class name 注册的类名，使用BUTTON则为按钮
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;设置&#34;</span><span class=p>),</span>          <span class=c1>// window name 按钮名称
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>WS_CHILD</span> <span class=o>|</span> <span class=n>WS_VISIBLE</span><span class=p>,</span> <span class=c1>// window style 子窗口控件样式：子窗口、创建后可以看到
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>450</span><span class=p>,</span>                   <span class=c1>// horizontal position of window 在父窗口上的x坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>150</span><span class=p>,</span>                   <span class=c1>// vertical position of window 在父窗口上的y坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>80</span><span class=p>,</span>                    <span class=c1>// window width 控件宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>20</span><span class=p>,</span>                    <span class=c1>// window height 控件高度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>hwnd</span><span class=p>,</span>                  <span class=c1>// menu handle or child identifier 父窗口句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=n>HWND</span><span class=p>)</span><span class=n>CWA_BUTTON_0</span><span class=p>,</span>    <span class=c1>// menu handle or child identifier 子窗口标识
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>gHinstance</span><span class=p>,</span>            <span class=c1>// handle to application instance 模块
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nb>NULL</span>                   <span class=c1>// window-creation data 附加数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 创建&#34;获取&#34;按钮
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CreateWindow</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;BUTTON&#34;</span><span class=p>),</span>        <span class=c1>// registered class name 注册的类名，使用BUTTON则为按钮
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;获取&#34;</span><span class=p>),</span>          <span class=c1>// window name 按钮名称
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>WS_CHILD</span> <span class=o>|</span> <span class=n>WS_VISIBLE</span><span class=p>,</span> <span class=c1>// window style 子窗口控件样式：子窗口、创建后可以看到
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>450</span><span class=p>,</span>                   <span class=c1>// horizontal position of window 在父窗口上的x坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>100</span><span class=p>,</span>                   <span class=c1>// vertical position of window 在父窗口上的y坐标
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>80</span><span class=p>,</span>                    <span class=c1>// window width 控件宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=mi>20</span><span class=p>,</span>                    <span class=c1>// window height 控件高度
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>hwnd</span><span class=p>,</span>                  <span class=c1>// menu handle or child identifier 父窗口句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=n>HWND</span><span class=p>)</span><span class=n>CWA_BUTTON_1</span><span class=p>,</span>    <span class=c1>// menu handle or child identifier 子窗口标识
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>gHinstance</span><span class=p>,</span>            <span class=c1>// handle to application instance 模块
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nb>NULL</span>                   <span class=c1>// window-creation data 附加数据
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 当按钮点击则处理
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=nl>WM_COMMAND</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 宏WM_COMMAND中，wParam参数的低16位中有标识，根据标识我们才能判断哪个按钮和编辑框，使用LOWORD()可以获取低16位
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>switch</span> <span class=p>(</span><span class=n>LOWORD</span><span class=p>(</span><span class=n>wParam</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 当按钮为设置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nl>CWA_BUTTON_0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// SetDlgItemText函数修改编辑框内容
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>SetDlgItemText</span><span class=p>(</span><span class=n>hwnd</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>CWA_EDIT</span><span class=p>,</span> <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;HACK THE WORLD&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 当按钮为获取
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=nl>CWA_BUTTON_1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// MessageBox弹框输出编辑框内容
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>TCHAR</span> <span class=n>szEditBuffer</span><span class=p>[</span><span class=mh>0x80</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>GetDlgItemText</span><span class=p>(</span><span class=n>hwnd</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>CWA_EDIT</span><span class=p>,</span> <span class=n>szEditBuffer</span><span class=p>,</span> <span class=mh>0x80</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>MessageBox</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>szEditBuffer</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div><h2 id=虚拟内存与物理内存 class=heading-element><a href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e4%b8%8e%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98 class=heading-mark></a>虚拟内存与物理内存</h2><h3 id=可使用的物理内存 class=heading-element><a href=#%e5%8f%af%e4%bd%bf%e7%94%a8%e7%9a%84%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98 class=heading-mark></a>可使用的物理内存</h3><p>MmNumberOfPhysicalPages*4 = 物理内存</p><p>虚拟内存（硬盘）</p><h3 id=可识别的物理内存 class=heading-element><a href=#%e5%8f%af%e8%af%86%e5%88%ab%e7%9a%84%e7%89%a9%e7%90%86%e5%86%85%e5%ad%98 class=heading-mark></a>可识别的物理内存</h3><p><strong>32位操作系统最多可以识别物理内存为64G</strong>，但是操作系统会进行限制，<strong>例如XP这个系统只能识别4G的物理内存</strong>（Windows Server 2003服务器版本可以识别4G以上）。</p><p>但是我们可以通过HOOK系统函数来突破XP操作系统的4GB限制</p><h2 id=私有内存的申请释放 class=heading-element><a href=#%e7%a7%81%e6%9c%89%e5%86%85%e5%ad%98%e7%9a%84%e7%94%b3%e8%af%b7%e9%87%8a%e6%94%be class=heading-mark></a>私有内存的申请释放</h2><p>物理内存分为两类，一个是私有内存（Private）一个是共享内存（Mapped），私有内存的意思是这块物理内存（物理页）只有你使用，而共享内存则是多个进程一起用。</p><p>申请内存的方式：</p><ol><li>通过virtualAllocate/virtualAllocEx申请的：私有</li><li>通过CreateFileMapping映射的：共享</li></ol><h3 id=virtualalloc class=heading-element><a href=#virtualalloc class=heading-mark></a>VirtualAlloc</h3><div class=highlight id=id-54><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>LPVOID</span> <span class=nf>VirtualAlloc</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPVOID</span> <span class=n>lpAddress</span><span class=p>,</span>        <span class=c1>// region to reserve or commit 要分配的内存区域的地址，没有特殊需求通常不指定
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SIZE_T</span> <span class=n>dwSize</span><span class=p>,</span>           <span class=c1>// size of region 分配的大小，一个物理页大小是0x1000（4KB），看你需要申请多少个物理页就乘以多少
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>flAllocationType</span><span class=p>,</span>  <span class=c1>// type of allocation 分配的类型，常用的是MEM_COMMIT（占用线性地址，也需要物理内存）和MEM_RESERVE（占用线性地址，但不需要物理内存）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>flProtect</span>          <span class=c1>// type of access protection 该内存的初始保护属性
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>占用线性地址并分配物理内存，可读可写：</p><div class=highlight id=id-55><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VirtualAlloc</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>,</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span><span class=c1>// 虚拟地址仍然保留，物理页不保留
</span></span></span></code></pre></div><p>想要释放物理内存，释放线性地址就写如下代码</p><div class=highlight id=id-56><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VirtualFree</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MEM_RESERVE</span><span class=p>);</span><span class=c1>// 虚拟地址不保留
</span></span></span></code></pre></div><h2 id=共享内存的申请释放 class=heading-element><a href=#%e5%85%b1%e4%ba%ab%e5%86%85%e5%ad%98%e7%9a%84%e7%94%b3%e8%af%b7%e9%87%8a%e6%94%be class=heading-mark></a>共享内存的申请释放</h2><h3 id=createfilemapping class=heading-element><a href=#createfilemapping class=heading-mark></a>CreateFileMapping</h3><p>内核对象，这个对象可以为我们准备物理内存，还可以将文件映射到物理页</p><div class=highlight id=id-57><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateFileMapping</span><span class=p>(</span> 
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>,</span>                       <span class=c1>// handle to file 文件句柄，如果不想将文件映射到物理页，则不指定该参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpAttributes</span><span class=p>,</span> <span class=c1>// security 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>flProtect</span><span class=p>,</span>                    <span class=c1>// protection 保护模式，物理页的属性
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwMaximumSizeHigh</span><span class=p>,</span>            <span class=c1>// high-order DWORD of size 高32位，在32位计算机里通常设置为空
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwMaximumSizeLow</span><span class=p>,</span>             <span class=c1>// low-order DWORD of size 低32位，指定物理内存的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCTSTR</span> <span class=n>lpName</span>                      <span class=c1>// object name 对象名字，公用时写，自己使用则可以不指定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>创建好物理页后，还需要通过<strong>MapViewOffile函数</strong>将物理页与线性地址进行映射：</p><div class=highlight id=id-58><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>LPVOID</span> <span class=nf>MapViewOfFile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hFileMappingObject</span><span class=p>,</span>   <span class=c1>// handle to file-mapping object file-mapping对象的句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwDesiredAccess</span><span class=p>,</span>       <span class=o>//</span> <span class=n>access</span> <span class=n>mode</span> <span class=err>访问模式</span><span class=p>(</span><span class=err>虚拟内存的限制必须比物理地址更加严格</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>dwFileOffsetHigh</span><span class=p>,</span>      <span class=c1>// high-order DWORD of offset 高32位，在32位计算机里通常设置为空
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwFileOffsetLow</span><span class=p>,</span>       <span class=c1>// low-order DWORD of offset 低32位，指定从哪里开始映射
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SIZE_T</span> <span class=n>dwNumberOfBytesToMap</span>  <span class=c1>// number of bytes to map 共享内存的大小，一般与物理页大小一致
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>示例代码，也可以双开一个，直接读</p><div class=highlight id=id-59><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include &lt;windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>##define MapFileName &#34;共享内存&#34;
</span></span></span><span class=line><span class=cl><span class=cp>##define BUF_SIZE 0x1000
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>HANDLE</span> <span class=n>g_hMapFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>LPTSTR</span> <span class=n>g_lpBuff</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 内核对象：准备好物理页，无效句柄值-1、物理页可读写、申请一个物理页
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>g_hMapFile</span> <span class=o>=</span> <span class=n>CreateFileMapping</span><span class=p>(</span><span class=n>INVALID_HANDLE_VALUE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>,</span> <span class=p>(</span><span class=n>LPCWSTR</span><span class=p>)</span><span class=n>MapFileName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将物理页与线性地址进行映射
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>g_lpBuff</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPTSTR</span><span class=p>)</span><span class=n>MapViewOfFile</span><span class=p>(</span><span class=n>g_hMapFile</span><span class=p>,</span> <span class=n>FILE_MAP_ALL_ACCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>BUF_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 向物理内存中存储
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=p>(</span><span class=n>PDWORD</span><span class=p>)</span><span class=n>g_lpBuff</span> <span class=o>=</span> <span class=mh>0x12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 关闭映射，关闭映射则表示释放了线形地址，但是物理页还存在
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UnmapViewOfFile</span><span class=p>(</span><span class=n>g_lpBuff</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 关闭句柄，这样才能释放物理页，但需要等待物理页使用完毕才会真正的释放，这里只是告诉系统我们当前进程不再使用该句柄（物理页）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>g_hMapFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=文件系统未完成文件操作相关api未写 class=heading-element><a href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%9c%aa%e5%ae%8c%e6%88%90%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e7%9b%b8%e5%85%b3api%e6%9c%aa%e5%86%99 class=heading-mark></a>文件系统(未完成，文件操作相关API未写)</h2><p>文件系统是操作系统用于管理磁盘上文件的方法和数据结构；简单点说就是在磁盘上如何组织文件的<strong>方法</strong>。</p><p>文件系统是软件层面的。</p><table><thead><tr><th></th><th>NTFS</th><th>FAT32</th></tr></thead><tbody><tr><td>磁盘分区容量</td><td>2T</td><td>32G</td></tr><tr><td>单个文件容量</td><td>4G以上</td><td>最大4G</td></tr><tr><td>EFS加密</td><td>支持</td><td>不支持</td></tr><tr><td>磁盘配额</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id=卷相关api class=heading-element><a href=#%e5%8d%b7%e7%9b%b8%e5%85%b3api class=heading-mark></a>卷相关API</h3><h4 id=获取卷逻辑驱动器 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e5%8d%b7%e9%80%bb%e8%be%91%e9%a9%b1%e5%8a%a8%e5%99%a8 class=heading-mark></a>获取卷（逻辑驱动器）</h4><p>函数<strong>GetLogicalDrives</strong>用于获取当前计算机所有逻辑驱动器，语法格式为：</p><div class=highlight id=id-60><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>GetLogicalDrives</span><span class=p>(</span><span class=n>VOID</span><span class=p>);</span> <span class=c1>// 返回值是一个DOWRD，没有参数
</span></span></span></code></pre></div><div class=highlight id=id-61><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>gLd</span> <span class=o>=</span> <span class=n>GetLogicalDrives</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;GetLogicalDrives: %x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>gLd</span><span class=p>);</span></span></span></code></pre></div><h4 id=获取所有逻辑驱动器的字符串 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e6%89%80%e6%9c%89%e9%80%bb%e8%be%91%e9%a9%b1%e5%8a%a8%e5%99%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2 class=heading-mark></a>获取所有逻辑驱动器的字符串</h4><div class=highlight id=id-62><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>GetLogicalDriveStrings</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>nBufferLength</span><span class=p>,</span>  <span class=c1>// size of buffer 输入类型，要获取字符串的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTSTR</span> <span class=n>lpBuffer</span>       <span class=c1>// drive strings buffer 输出类型，将获取的字符串放到该参数中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p><img loading=lazy src=image-20220404184443807.png alt=image-20220404184443807 srcset="image-20220404184443807.png?size=small, image-20220404184443807.png?size=medium 1.5x, image-20220404184443807.png?size=large 2x" data-title=image-20220404184443807 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h4 id=获取卷逻辑驱动器的类型 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e5%8d%b7%e9%80%bb%e8%be%91%e9%a9%b1%e5%8a%a8%e5%99%a8%e7%9a%84%e7%b1%bb%e5%9e%8b class=heading-mark></a>获取卷（逻辑驱动器）的类型</h4><div class=highlight id=id-63><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>UINT</span> <span class=nf>GetDriveType</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpRootPathName</span>   <span class=c1>// root directory 根目录，这里我们可以使用驱动器字符串
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=获取卷信息 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e5%8d%b7%e4%bf%a1%e6%81%af class=heading-mark></a>获取卷信息</h3><div class=highlight id=id-64><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>GetVolumeInformation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpRootPathName</span><span class=p>,</span>           <span class=c1>// root directory 输入类型，驱动器字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTSTR</span> <span class=n>lpVolumeNameBuffer</span><span class=p>,</span>        <span class=c1>// volume name buffer 输出类型，返回卷名
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>nVolumeNameSize</span><span class=p>,</span>            <span class=c1>// length of name buffer 输入类型，卷名长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpVolumeSerialNumber</span><span class=p>,</span>     <span class=c1>// volume serial number 输出类型，卷宗序列号
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpMaximumComponentLength</span><span class=p>,</span> <span class=c1>// maximum file name length 输出类型，指定文件系统支持的文件名组件的最大长度
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpFileSystemFlags</span><span class=p>,</span>        <span class=c1>// file system options 输出类型，与指定文件系统相关的标志
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTSTR</span> <span class=n>lpFileSystemNameBuffer</span><span class=p>,</span>    <span class=c1>// file system name buffer 输出类型，文件系统（如FAT或NTFS）名称
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>nFileSystemNameSize</span>         <span class=c1>// length of file system name buffer 输入类型，文件系统名称的长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p><img loading=lazy src=image-20220404222404635.png alt=image-20220404222404635 srcset="image-20220404222404635.png?size=small, image-20220404222404635.png?size=medium 1.5x, image-20220404222404635.png?size=large 2x" data-title=image-20220404222404635 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h3 id=目录相关api class=heading-element><a href=#%e7%9b%ae%e5%bd%95%e7%9b%b8%e5%85%b3api class=heading-mark></a>目录相关API</h3><h3 id=创建目录 class=heading-element><a href=#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95 class=heading-mark></a>创建目录</h3><p>CreateDirectory</p><div class=highlight id=id-65><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>CreateDirectory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpPathName</span><span class=p>,</span>                         <span class=c1>// directory name 目录名称，需要指定完整路径包含盘符的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpSecurityAttributes</span>  <span class=c1>// SD 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><div class=highlight id=id-66><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CreateDirectory</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;E:</span><span class=se>\\</span><span class=s>A&#34;</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>);</span></span></span></code></pre></div><h3 id=删除目录 class=heading-element><a href=#%e5%88%a0%e9%99%a4%e7%9b%ae%e5%bd%95 class=heading-mark></a>删除目录</h3><div class=highlight id=id-67><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>RemoveDirectory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpPathName</span>   <span class=c1>// directory name 目录名称，需要指定完整路径包含盘符的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=修改目录名称 class=heading-element><a href=#%e4%bf%ae%e6%94%b9%e7%9b%ae%e5%bd%95%e5%90%8d%e7%a7%b0 class=heading-mark></a>修改目录名称</h3><div class=highlight id=id-68><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>MoveFile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpExistingFileName</span><span class=p>,</span> <span class=c1>// file name 目录名
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPCTSTR</span> <span class=n>lpNewFileName</span>       <span class=c1>// new file name 新目录名
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=获取程序当前目录 class=heading-element><a href=#%e8%8e%b7%e5%8f%96%e7%a8%8b%e5%ba%8f%e5%bd%93%e5%89%8d%e7%9b%ae%e5%bd%95 class=heading-mark></a>获取程序当前目录</h3><div class=highlight id=id-69><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>GetCurrentDirectory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span> <span class=n>nBufferLength</span><span class=p>,</span>  <span class=c1>// size of directory buffer 输入类型，获取当前目录名的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTSTR</span> <span class=n>lpBuffer</span>       <span class=c1>// directory buffer 输出类型，当前目录名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=设置程序当前目录 class=heading-element><a href=#%e8%ae%be%e7%bd%ae%e7%a8%8b%e5%ba%8f%e5%bd%93%e5%89%8d%e7%9b%ae%e5%bd%95 class=heading-mark></a>设置程序当前目录</h3><div class=highlight id=id-70><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>SetCurrentDirectory</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpPathName</span>   <span class=c1>// new directory name 新的目录名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h3 id=文件相关api class=heading-element><a href=#%e6%96%87%e4%bb%b6%e7%9b%b8%e5%85%b3api class=heading-mark></a>文件相关API</h3><h3 id=创建文件 class=heading-element><a href=#%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6 class=heading-mark></a>创建文件</h3><div class=highlight id=id-71><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateFile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCTSTR</span> <span class=n>lpFileName</span><span class=p>,</span>                         <span class=c1>// file name 文件名
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwDesiredAccess</span><span class=p>,</span>                      <span class=c1>// access mode 访问模式
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwShareMode</span><span class=p>,</span>                          <span class=c1>// share mode 共享模式，如果为0则是排他性，就是目前在使用时其他人是无法使用的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpSecurityAttributes</span><span class=p>,</span> <span class=c1>// SD 安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwCreationDisposition</span><span class=p>,</span>                <span class=c1>// how to create 如何创建，可以打开一个已经存在的文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwFlagsAndAttributes</span><span class=p>,</span>                 <span class=c1>// file attributes 文件属性，可以创建隐藏文件
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>HANDLE</span> <span class=n>hTemplateFile</span>                        <span class=c1>// handle to template file 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p>以可读可写方式不管有没有，有就覆盖没有就新建的方式创建一个隐藏文件</p><div class=highlight id=id-72><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CreateFile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;E:</span><span class=se>\\</span><span class=s>A.txt&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=n>GENERIC_READ</span> <span class=o>|</span> <span class=n>GENERIC_WRITE</span><span class=p>,</span><span class=c1>//访问模式
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>                     <span class=c1>//共享模式，如果为0则是排他性，就是目前在使用时其他人是无法使用的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>NULL</span><span class=p>,</span>                  <span class=c1>// SD
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CREATE_ALWAYS</span><span class=p>,</span>         <span class=c1>//如何创建，可以打开一个已经存在的文件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>FILE_ATTRIBUTE_HIDDEN</span><span class=p>,</span> <span class=c1>//文件属性，可以创建隐藏文件
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>NULL</span>                   <span class=c1>//创建文件的句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>);</span></span></span></code></pre></div><h3 id=关闭文件 class=heading-element><a href=#%e5%85%b3%e9%97%ad%e6%96%87%e4%bb%b6 class=heading-mark></a>关闭文件</h3><p>未完成&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;待续&mldr;&mldr;&mldr;&mldr;..</p><h2 id=内存映射文件 class=heading-element><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6 class=heading-mark></a>内存映射文件</h2><p>内存映射文件，将硬盘某个文件映射到<strong>物理页</strong>上，然后再将物理页映射到<strong>虚拟内存</strong>中。</p><h3 id=内存映射文件读写 class=heading-element><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e8%af%bb%e5%86%99 class=heading-mark></a>内存映射文件读写</h3><ol><li>创建文件</li><li>创建FileMapping对象</li><li>物理页映射到虚拟内存</li><li>之后就是读写文件了</li><li>关闭资源</li></ol><div class=highlight id=id-73><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include &lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hMapFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPVOID</span> <span class=n>lpAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 创建文件（获取文件句柄）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hFile</span> <span class=o>=</span> <span class=n>CreateFile</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;E:</span><span class=se>\\</span><span class=s>1.txt&#34;</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>        <span class=n>GENERIC_READ</span> <span class=o>|</span> <span class=n>GENERIC_WRITE</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>OPEN_EXISTING</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=n>FILE_ATTRIBUTE_NORMAL</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断CreateFile是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>hFile</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CreateFile failed: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 创建FileMapping对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hMapFile</span> <span class=o>=</span> <span class=n>CreateFileMapping</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>hFile</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断CreateFileMapping是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>hMapFile</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CreateFileMapping failed: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 物理页映射到虚拟内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lpAddr</span> <span class=o>=</span> <span class=n>MapViewOfFile</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>,</span> <span class=n>FILE_MAP_COPY</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 读取文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>dwTest1</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>LPDWORD</span><span class=p>)</span><span class=n>lpAddr</span><span class=p>;</span> <span class=c1>// 读取最开始的4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;dwTest1: %x </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dwTest1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 写文件 
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>lpAddr</span> <span class=o>=</span> <span class=p>(</span><span class=n>LPVOID</span><span class=p>)</span><span class=mh>0x11111111</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=c1>// 如果你希望修改可以立即生效，我们可以通过FlushViewOfFile函数来强制更新缓存
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=n>FlushViewOfFile</span><span class=p>(((</span><span class=n>LPDWORD</span><span class=p>)</span><span class=n>lpAddr</span><span class=p>),</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=n>printf</span><span class=p>(</span><span class=s>&#34;ok&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 关闭资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UnmapViewOfFile</span><span class=p>(</span><span class=n>lpAddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=内存映射文件之共享 class=heading-element><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b9%8b%e5%85%b1%e4%ba%ab class=heading-mark></a>内存映射文件之共享</h3><p>实现如下的情况</p><p><img loading=lazy src=image-20220404232317050.png alt=image-20220404232317050 srcset="image-20220404232317050.png?size=small, image-20220404232317050.png?size=medium 1.5x, image-20220404232317050.png?size=large 2x" data-title=image-20220404232317050 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>A程序写入，B程序读取：</p><div class=highlight id=id-74><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##define MAPPINGNAME &#34;Share File&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>MappingFile</span><span class=p>(</span><span class=n>LPSTR</span> <span class=n>lpcFile</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hMapFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPVOID</span> <span class=n>lpAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 创建文件（获取文件句柄）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hFile</span> <span class=o>=</span> <span class=n>CreateFile</span><span class=p>(</span><span class=n>lpcFile</span><span class=p>,</span> <span class=n>GENERIC_READ</span><span class=o>|</span><span class=n>GENERIC_WRITE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>OPEN_EXISTING</span><span class=p>,</span> <span class=n>FILE_ATTRIBUTE_NORMAL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 判断CreateFile是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>hFile</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CreateFile failed: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 创建FileMapping对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hMapFile</span> <span class=o>=</span> <span class=n>CreateFileMapping</span><span class=p>(</span><span class=n>hFile</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>MAPPINGNAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=c1>// 判断CreateFileMapping是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>hMapFile</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;CreateFileMapping failed: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 物理页映射到虚拟内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lpAddr</span> <span class=o>=</span> <span class=n>MapViewOfFile</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>,</span> <span class=n>FILE_MAP_ALL_ACCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 读取文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// DWORD dwTest1 = *(LPDWORD)lpAddr; // 读取最开始的4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// printf(&#34;dwTest1: %x \n&#34;, dwTest1);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 5. 写文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=p>(</span><span class=n>LPDWORD</span><span class=p>)</span><span class=n>lpAddr</span> <span class=o>=</span> <span class=mh>0x41414142</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FlushViewOfFile</span><span class=p>(((</span><span class=n>LPDWORD</span><span class=p>)</span><span class=n>lpAddr</span><span class=p>),</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Process A Write&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 关闭资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UnmapViewOfFile</span><span class=p>(</span><span class=n>lpAddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>B程序：</p><div class=highlight id=id-75><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##define MAPPINGNAME &#34;Share File&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=nf>MappingFile</span><span class=p>(</span><span class=n>LPSTR</span> <span class=n>lpcFile</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hMapFile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPVOID</span> <span class=n>lpAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 打开FileMapping对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    OpenFileMapping 函数语法格式：
</span></span></span><span class=line><span class=cl><span class=cm>    HANDLE OpenFileMapping(
</span></span></span><span class=line><span class=cl><span class=cm>        DWORD dwDesiredAccess,  // access mode 访问模式
</span></span></span><span class=line><span class=cl><span class=cm>        BOOL bInheritHandle,    // inherit flag 继承标识，为真则表示这个可以被新进程继承，为假反之
</span></span></span><span class=line><span class=cl><span class=cm>        LPCTSTR lpName          // object name 对象名称
</span></span></span><span class=line><span class=cl><span class=cm>    );
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>hMapFile</span> <span class=o>=</span> <span class=n>OpenFileMapping</span><span class=p>(</span><span class=n>FILE_MAP_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>MAPPINGNAME</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 物理页映射到虚拟内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lpAddr</span> <span class=o>=</span> <span class=n>MapViewOfFile</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>,</span> <span class=n>FILE_MAP_ALL_ACCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 读取文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DWORD</span> <span class=n>dwTest1</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=n>LPDWORD</span><span class=p>)</span><span class=n>lpAddr</span><span class=p>;</span> <span class=c1>// 读取最开始的4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;dwTest1: %x </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dwTest1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 写文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// *(LPDWORD)lpAddr = 0x41414142;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Process B Read&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 关闭资源
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>UnmapViewOfFile</span><span class=p>(</span><span class=n>lpAddr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hMapFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=内存映射文件之写拷贝 class=heading-element><a href=#%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b9%8b%e5%86%99%e6%8b%b7%e8%b4%9d class=heading-mark></a>内存映射文件之写拷贝</h3><p>实际上我们程序调用的user32.dll这类dll文件，也是通过这种方式进行调用的，如果我们进程A修改了某个DLL，就会导致进程B出问题。</p><p>为了解决这种隐患，我们可以使用写拷贝的方式来处理。</p><p>写拷贝的实现就是<strong>MapViewOfFile函数</strong>中的第二个参数值为<strong>FILE_MAP_COPY</strong>，<strong>它的意思表示当你在写的时候进行拷贝</strong>。写拷贝属性时候，写入时并<strong>不会影响</strong>原本的文件内容</p><p><img loading=lazy src=image-20220404235855922.png alt=image-20220404235855922 srcset="image-20220404235855922.png?size=small, image-20220404235855922.png?size=medium 1.5x, image-20220404235855922.png?size=large 2x" data-title=image-20220404235855922 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=静态链接库 class=heading-element><a href=#%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93 class=heading-mark></a>静态链接库</h2><p>动态链接和静态链接之前pwn的时候搞过，就不写的太详细了。</p><p>写好之后，将生成的.h文件和.lib文件放到项目的根目录，然后引用：</p><div class=highlight id=id-76><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>##include &#34;xxxx.h&#34;
</span></span></span><span class=line><span class=cl><span class=cp>##pragma comment(lib, &#34;xxxx.lib&#34;)</span></span></span></code></pre></div><h2 id=动态链接库 class=heading-element><a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93 class=heading-mark></a>动态链接库</h2><p>使用的是VS2022,，创建动态链接库项目，把其他的文件删掉，新建MyDLL的h和cpp文件，不使用预编译头。</p><p><img loading=lazy src=image-20220405004843503.png alt=image-20220405004843503 srcset="image-20220405004843503.png?size=small, image-20220405004843503.png?size=medium 1.5x, image-20220405004843503.png?size=large 2x" data-title=image-20220405004843503 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>.h:</p><div class=highlight id=id-77><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kr>__declspec</span><span class=p>(</span><span class=n>dllexport</span><span class=p>)</span>  <span class=kt>int</span> <span class=nf>ADD</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span><span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=kr>__declspec</span><span class=p>(</span><span class=n>dllexport</span><span class=p>)</span>  <span class=kt>int</span> <span class=nf>SUB</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span></span></span></code></pre></div><p>.cpp:</p><div class=highlight id=id-78><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>ADD</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>SUB</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>生成：</p><p><img loading=lazy src=image-20220405005507193.png alt=image-20220405005507193 srcset="image-20220405005507193.png?size=small, image-20220405005507193.png?size=medium 1.5x, image-20220405005507193.png?size=large 2x" data-title=image-20220405005507193 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>使用：</p><p>生成的dll，将dll，lib和h文件放到使用dll的项目中，vcxproj同级。</p><p>之后分别右键导入h和lib、dll，直接使用就可：</p><p><img loading=lazy src=image-20220405013109265.png alt=image-20220405013109265 srcset="image-20220405013109265.png?size=small, image-20220405013109265.png?size=medium 1.5x, image-20220405013109265.png?size=large 2x" data-title=image-20220405013109265 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>还可以这样使用：</p><div class=highlight id=id-79><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl> <span class=c1>// 将DLL文件复制到项目目录下
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤1：定义函数指针,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>typedef</span> <span class=nf>int</span> <span class=p>(</span><span class=o>*</span><span class=n>lpAdd</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤2：声明函数指针变量,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lpAdd</span> <span class=n>myAdd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤3：动态加载dll到内存中,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// LoadLibrary函数会先从当前目录寻找，然后在系统目录寻找
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HINSTANCE</span> <span class=n>hModule</span> <span class=o>=</span> <span class=n>LoadLibrary</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;MyDLL.dll&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤4：获取函数地址,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>myAdd</span> <span class=o>=</span> <span class=p>(</span><span class=n>lpAdd</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hModule</span><span class=p>,</span> <span class=s>&#34;ADD&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤5：调用函数,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>myAdd</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 步骤6：释放动态链接库,如：
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>FreeLibrary</span><span class=p>(</span><span class=n>hModule</span><span class=p>);</span></span></span></code></pre></div><p><img loading=lazy src=image-20220405111423572.png alt=image-20220405111423572 srcset="image-20220405111423572.png?size=small, image-20220405111423572.png?size=medium 1.5x, image-20220405111423572.png?size=large 2x" data-title=image-20220405111423572 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=隐式链接 class=heading-element><a href=#%e9%9a%90%e5%bc%8f%e9%93%be%e6%8e%a5 class=heading-mark></a>隐式链接</h2><p>将动态链接生成的lib和dll文件放到项目目录 ，</p><div class=highlight id=id-80><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include &lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##pragma comment(lib, &#34;MyDLL.lib&#34;)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kr>__declspec</span><span class=p>(</span><span class=n>dllimport</span><span class=p>)</span> <span class=kt>int</span> <span class=n>ADD</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>__declspec</span><span class=p>(</span><span class=n>dllimport</span><span class=p>)</span> <span class=kt>int</span> <span class=n>SUB</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>SUB</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=n>ADD</span><span class=p>(</span><span class=mi>23</span><span class=p>,</span> <span class=mi>11</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h3 id=dllmain class=heading-element><a href=#dllmain class=heading-mark></a>DLLMain</h3><p>dll的入口函数是DLLMain，DLLMain可能执行很多次</p><div class=highlight id=id-81><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>WINAPI</span> <span class=nf>DllMain</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HINSTANCE</span> <span class=n>hinstDLL</span><span class=p>,</span>   <span class=c1>// handle to the DLL module DLL模块的句柄，当前DLL被加载到什么位置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>fdwReason</span><span class=p>,</span>      <span class=c1>// reason for calling function DLL被调用的原因，有4种情况：DLL_PROCESS_ATTACH（当某个进程第一次执行LoadLibrary）、DLL_PROCESS_DETACH（当某个进程释放了DLL）、DLL_THREAD_ATTACH（当某个进程的其他线程再次执行LoadLibrary）、DLL_THREAD_DETACH（当某个进程的其他线程释放了DLL）
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPVOID</span> <span class=n>lpvReserved</span>    <span class=c1>// reserved
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><h2 id=远程线程 class=heading-element><a href=#%e8%bf%9c%e7%a8%8b%e7%ba%bf%e7%a8%8b class=heading-mark></a>远程线程</h2><h3 id=createremotethread class=heading-element><a href=#createremotethread class=heading-mark></a>CreateRemoteThread</h3><div class=highlight id=id-82><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateRemoteThread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>,</span>                          <span class=c1>// handle to process 输入类型，进程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpThreadAttributes</span><span class=p>,</span> <span class=c1>// SD 输入类型，安全属性，包含安全描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SIZE_T</span> <span class=n>dwStackSize</span><span class=p>,</span>                       <span class=c1>// initial stack size 输入类型，堆大小
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPTHREAD_START_ROUTINE</span> <span class=n>lpStartAddress</span><span class=p>,</span>    <span class=c1>// thread function 输入类型，线程函数，线程函数地址应该是在别的进程中存在的
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>,</span>                       <span class=c1>// thread argument　输入类型，线程参数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DWORD</span> <span class=n>dwCreationFlags</span><span class=p>,</span>                    <span class=c1>// creation option 输入类型，创建设置
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LPDWORD</span> <span class=n>lpThreadId</span>                        <span class=c1>// thread identifier 输出类型，线程id
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>);</span></span></span></code></pre></div><p><strong>CreateThread</strong>函数是在当前进程中创建线程，而<strong>CreateRemoteThread</strong>函数是允许在其他进程中创建线程，所以<strong>远程线程就可以理解为是非本进程中的线程</strong>。</p><p>A进程简单的输出10句话，之后使用B进程创建远程进程</p><p>A:</p><div class=highlight id=id-83><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Fun</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Fun running... </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Sleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParameter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Fun</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hThread</span> <span class=o>=</span> <span class=n>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=n>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>B:执行的远程线程的线程函数地址应该是在别的进程中存在的</p><div class=highlight id=id-84><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>MyCreateRemoteThread</span><span class=p>(</span><span class=n>DWORD</span> <span class=n>dwProcessId</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>dwProcessAddr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwThreadId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 获取进程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>PROCESS_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwProcessId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断OpenProcess是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>hProcess</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;OpenProcess failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 创建远程线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hThread</span> <span class=o>=</span> <span class=n>CreateRemoteThread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>hProcess</span><span class=p>,</span>                          <span class=c1>// handle to process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>NULL</span><span class=p>,</span> <span class=c1>// SD
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>                       <span class=c1>// initial stack size
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>dwProcessAddr</span><span class=p>,</span>    <span class=c1>// thread function
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nb>NULL</span><span class=p>,</span>                       <span class=c1>// thread argument
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=mi>0</span><span class=p>,</span>                    <span class=c1>// creation option
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>&amp;</span><span class=n>dwThreadId</span>                        <span class=c1>// thread identifier
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断CreateRemoteThread是否执行成功
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>hThread</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;CreateRemoteThread failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 关闭
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 返回
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>成功执行！</p><p><img loading=lazy src=image-20220405121345946.png alt=image-20220405121345946 srcset="image-20220405121345946.png?size=small, image-20220405121345946.png?size=medium 1.5x, image-20220405121345946.png?size=large 2x" data-title=image-20220405121345946 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=远程线程注入 class=heading-element><a href=#%e8%bf%9c%e7%a8%8b%e7%ba%bf%e7%a8%8b%e6%b3%a8%e5%85%a5 class=heading-mark></a>远程线程注入</h2><p>如果我们想要创建远程线程调用自己定义的线程函数就需要使用<strong>远程线程注入</strong>技术。</p><h3 id=什么是注入 class=heading-element><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%a8%e5%85%a5 class=heading-mark></a>什么是注入</h3><p>所谓注入就是在第三方进程不知道或者不允许的情况下将模块或者代码写入对方进程空间，并设法执行的技术。</p><p>在安全领域，“注入”是非常重要的一种技术手段，注入与反注入也一直处于不断变化的，而且也愈来愈激烈的对抗当中。</p><p><strong>已知的注入方式：</strong></p><p>远程线程注入、APC注入、消息钩子注入、注册表注入、导入表注入、输入法注入等等。</p><h3 id=远程线程注入的流程 class=heading-element><a href=#%e8%bf%9c%e7%a8%8b%e7%ba%bf%e7%a8%8b%e6%b3%a8%e5%85%a5%e7%9a%84%e6%b5%81%e7%a8%8b class=heading-mark></a>远程线程注入的流程</h3><p>远程线程注入的思路就是在进程A中创建线程，<strong>将线程函数指向LoadLibrary函数</strong>。</p><p>那么为什么可以这样呢？这是因为我们执行远程线程函数满足返回值是4字节，一个参数是4字节即可（ThreadProc就是这样的条件）：</p><p>重新写个dll：</p><div class=highlight id=id-85><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>DWORD</span> <span class=n>WINAPI</span> <span class=nf>ThreadProc</span><span class=p>(</span><span class=n>LPVOID</span> <span class=n>lpParaneter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>10</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Sleep</span><span class=p>(</span><span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;DLL RUNNING...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>APIENTRY</span> <span class=nf>DllMain</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>hModule</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span>  <span class=n>ul_reason_for_call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>LPVOID</span> <span class=n>lpReserved</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>   <span class=c1>// 当进程执行LoadLibrary时创建一个线程，执行ThreadProc线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>switch</span> <span class=p>(</span><span class=n>ul_reason_for_call</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>DLL_PROCESS_ATTACH</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>CreateThread</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ThreadProc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>被注入的程序还是和之前那个一样，下面是注入的程序：（这里我搞了半天，最后还是32位的成功了。。。）</p><div class=highlight id=id-86><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>##include&lt;Windows.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp>##include&lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// LoadDll需要两个参数一个参数是进程ID，一个是DLL文件的路径
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>LoadDll</span><span class=p>(</span><span class=n>DWORD</span> <span class=n>dwProcessID</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>szDllPathName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>BOOL</span> <span class=n>bRet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hProcess</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwLoadAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LPVOID</span> <span class=n>lpAllocAddr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>dwThreadID</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>HMODULE</span> <span class=n>hModule</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bRet</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dwLoadAddr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>hProcess</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 获取进程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hProcess</span> <span class=o>=</span> <span class=n>OpenProcess</span><span class=p>(</span><span class=n>PROCESS_ALL_ACCESS</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>,</span> <span class=n>dwProcessID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>hProcess</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;OpenProcess failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 获取DLL文件路径的长度，并在最后+1，因为要加上0结尾的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dwLength</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>szDllPathName</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 在目标进程分配内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>lpAllocAddr</span> <span class=o>=</span> <span class=n>VirtualAllocEx</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_READWRITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>lpAllocAddr</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;VirtualAllocEx failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 4. 拷贝DLL路径名字到目标进程的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bRet</span> <span class=o>=</span> <span class=n>WriteProcessMemory</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=n>lpAllocAddr</span><span class=p>,</span> <span class=n>szDllPathName</span><span class=p>,</span> <span class=n>dwLength</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bRet</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;WriteProcessMemory failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 5. 获取模块句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// LoadLibrary这个函数是在kernel32.dll这个模块中的，所以需要现货区kernel32.dll这个模块的句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hModule</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hModule</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;GetModuleHandle failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 6. 获取LoadLibraryA函数地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dwLoadAddr</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hModule</span><span class=p>,</span> <span class=s>&#34;LoadLibraryA&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dwLoadAddr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;GetProcAddress failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hModule</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 7. 创建远程线程，加载DLL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>hThread</span> <span class=o>=</span> <span class=n>CreateRemoteThread</span><span class=p>(</span><span class=n>hProcess</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>(</span><span class=n>LPTHREAD_START_ROUTINE</span><span class=p>)</span><span class=n>dwLoadAddr</span><span class=p>,</span> <span class=n>lpAllocAddr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dwThreadID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hThread</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>OutputDebugString</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;CreateRemoteThread failed! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hModule</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 8. 关闭进程句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hProcess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>LoadDll</span><span class=p>(</span><span class=mi>27220</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span><span class=s>&#34;E:</span><span class=se>\\</span><span class=s>github</span><span class=se>\\</span><span class=s>Win32LearnCode</span><span class=se>\\</span><span class=s>Code</span><span class=se>\\</span><span class=s>lesson28</span><span class=se>\\</span><span class=s>MyDLL</span><span class=se>\\</span><span class=s>Debug</span><span class=se>\\</span><span class=s>MyDLL.dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>成功注入！！！</p><p><img loading=lazy src=image-20220405181829457.png alt=image-20220405181829457 srcset="image-20220405181829457.png?size=small, image-20220405181829457.png?size=medium 1.5x, image-20220405181829457.png?size=large 2x" data-title=image-20220405181829457 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><h2 id=模块隐藏 class=heading-element><a href=#%e6%a8%a1%e5%9d%97%e9%9a%90%e8%97%8f class=heading-mark></a>模块隐藏</h2><h3 id=模块隐藏-断链 class=heading-element><a href=#%e6%a8%a1%e5%9d%97%e9%9a%90%e8%97%8f-%e6%96%ad%e9%93%be class=heading-mark></a>模块隐藏-断链</h3><p>API是从这几个结构体（<strong>结构体属于3环应用层</strong>）中查询出来的：</p><ol><li>TEB(Thread Environment Block，线程环境块)，它存放线程的相关信息，每一个线程都有自己的TEB信息，FS:[0]即是当前线程的TEB。</li><li>PEB(Process Environment Block，进程环境块)，它存放进程的相关信息，每个进程都有自己的PEB信息，FS:[0x30]即当前进程的PEB。</li></ol><p>如下图所示（只介绍与本章节相关的信息）</p><ol><li>TEB第一个成员是一个结构体，这个结构体包含了当前线程栈栈底和当前线程栈的界限；TEB的<strong>020</strong>偏移是一个结构体，其包含了两个成员，一个是当前线程所在进程的PID和当前线程自己的线程ID；</li><li>PEB的<strong>00c</strong>偏移是一个结构体，这个结构体包括<strong>模块链表</strong>，API函数遍历模块就是查看这个链表。</li></ol><p><img loading=lazy src=image2021-6-3_22-31-12.png alt=image2021-6-3_22-31-12.png srcset="image2021-6-3_22-31-12.png?size=small, image2021-6-3_22-31-12.png?size=medium 1.5x, image2021-6-3_22-31-12.png?size=large 2x" data-title=image2021-6-3_22-31-12.png style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></p><p>FS寄存器中存储的就是当前正在使用的线程的TEB结构体的地址。</p><p>PEB结构体同理，我们只需要找到FS寄存器中存储地址的0x30偏移然后跟进即可</p><p>代码实现：</p><div class=highlight id=id-87><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>HideModule</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span> <span class=n>szModuleName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取模块的句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>HMODULE</span> <span class=n>hMod</span> <span class=o>=</span> <span class=n>GetModuleHandle</span><span class=p>(</span><span class=n>szModuleName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PLIST_ENTRY</span> <span class=n>Head</span><span class=p>,</span> <span class=n>Cur</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PPEB_LDR_DATA</span> <span class=n>ldr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PLDR_MODULE</span> <span class=n>ldmod</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kr>__asm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mov</span> <span class=n>eax</span><span class=p>,</span> <span class=nl>fs</span><span class=p>:[</span><span class=mh>0x30</span><span class=p>]</span> <span class=c1>// 取PEB结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>mov</span> <span class=n>ecx</span><span class=p>,</span> <span class=p>[</span><span class=n>eax</span> <span class=o>+</span> <span class=mh>0x0c</span><span class=p>]</span> <span class=c1>// 取PEB结构体的00c偏移的结构体，就是PEB_LDR_DATA
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>mov</span> <span class=n>ldr</span><span class=p>,</span> <span class=n>ecx</span> <span class=c1>// 将ecx给到ldr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 获取正在加载的模块列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Head</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>ldr</span><span class=o>-&gt;</span><span class=n>InLoadOrderModuleList</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Cur</span> <span class=o>=</span> <span class=n>Head</span><span class=o>-&gt;</span><span class=n>Flink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 宏CONTAINING_RECORD根据结构体中某成员的地址来推算出该结构体整体的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ldmod</span> <span class=o>=</span> <span class=n>CONTAINING_RECORD</span><span class=p>(</span><span class=n>Cur</span><span class=p>,</span> <span class=n>LDR_MODULE</span><span class=p>,</span> <span class=n>InLoadOrderModuleList</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 循环遍历，如果地址一致则表示找到对应模块来，就进行断链
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>hMod</span> <span class=o>==</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>BaseAddress</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 断链原理很简单就是将属性交错替换
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InLoadOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=o>-&gt;</span><span class=n>Flink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InLoadOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InLoadOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=o>-&gt;</span><span class=n>Blink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InLoadOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InInitializationOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=o>-&gt;</span><span class=n>Flink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InInitializationOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InInitializationOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=o>-&gt;</span><span class=n>Blink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InInitializationOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InMemoryOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=o>-&gt;</span><span class=n>Flink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InMemoryOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InMemoryOrderModuleList</span><span class=p>.</span><span class=n>Flink</span><span class=o>-&gt;</span><span class=n>Blink</span> <span class=o>=</span> <span class=n>ldmod</span><span class=o>-&gt;</span><span class=n>InMemoryOrderModuleList</span><span class=p>.</span><span class=n>Blink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>Cur</span> <span class=o>=</span> <span class=n>Cur</span><span class=o>-&gt;</span><span class=n>Flink</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>Head</span> <span class=o>!=</span> <span class=n>Cur</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2022-04-01 00:00:00">更新于 2022-04-01&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/ data-title=重拾Win32 data-hashtags><i class="fa-brands fa-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/ data-hashtag=[Win32]><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=http://ghostasky.github.io/posts/%E9%87%8D%E6%8B%BEwin32/ data-title=重拾Win32><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/springmvc%E5%88%9D%E6%8E%A2/ class=post-nav-item rel=prev title="Spring MVC初探"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Spring MVC初探</a>
<a href=/posts/2022-6-29-bypassavdynamics/ class=post-nav-item rel=next title=BypassAVDynamics[译]>BypassAVDynamics[译]<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.123.8"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.2"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>
<a href=/></a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div></div><div id=mask></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=preload href=/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1}}</script><script src=/js/theme.min.js defer></script></body></html>