<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>【译】Kernel Pool Exploitation on Windows 7 - Ghostasky&#39;s Blog</title><meta name="author" content="">
<meta name="author-link" content="">
<meta name="description" content="" /><meta name="keywords" content='Windows' /><meta itemprop="name" content="【译】Kernel Pool Exploitation on Windows 7">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2023-08-16T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-08-16T00:00:00+00:00" />
<meta itemprop="wordCount" content="16868">
<meta itemprop="keywords" content="Windows," /><meta property="og:title" content="【译】Kernel Pool Exploitation on Windows 7" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-08-16T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="【译】Kernel Pool Exploitation on Windows 7"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/" /><link rel="prev" href="http://ghostasky.github.io/posts/2023-8-hevd/" /><link rel="next" href="http://ghostasky.github.io/posts/2023-8-scoopthewindows10pool/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "【译】Kernel Pool Exploitation on Windows 7",
    "inLanguage": "zh-CN",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/ghostasky.github.io\/posts\/2023-8-kernelpoolexploitationonwin7\/"
    },"genre": "posts","keywords": "Windows","wordcount":  16868 ,
    "url": "http:\/\/ghostasky.github.io\/posts\/2023-8-kernelpoolexploitationonwin7\/","datePublished": "2023-08-16T00:00:00+00:00","dateModified": "2023-08-16T00:00:00+00:00","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "作者"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="Ghostasky&#39;s Blog" data-title="Ghostasky&#39;s Blog" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Ghostasky&#39;s Blog</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              >文章</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              >分类</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              >标签</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              >关于</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="切换主题">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="Ghostasky&#39;s Blog"><img loading="lazy" src="/images/fixit.png" alt="/images/fixit.png" data-title="/images/fixit.png" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-text">Ghostasky&#39;s Blog</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                >文章</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                >分类</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                >标签</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                >关于</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="切换主题"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="合集"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span>【译】Kernel Pool Exploitation on Windows 7</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><i class="fa-solid fa-user-circle" aria-hidden="true"></i>
      Anonymous</span></span><span class="post-included-in">&nbsp;收录于 <a href="/categories/technology/" class="post-category" title="分类 - Technology"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Technology</a></span></div><div class="post-meta-line"><span title="发布于 2023-08-16 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2023-08-16">2023-08-16</time></span>&nbsp;<span title="16868 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>约 16900 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>预计阅读 34 分钟</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>目录</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#1introduction">1.Introduction</a></li>
    <li><a href="#2kernel-pool-internals">2.Kernel Pool Internals</a>
      <ul>
        <li><a href="#21-non-uniform-memory-architecture">2.1 Non-Uniform Memory Architecture</a></li>
        <li><a href="#22-system-memory-pools">2.2 System Memory Pools</a></li>
        <li><a href="#23-pool-descriptor">2.3 Pool Descriptor</a></li>
        <li><a href="#24-listheads-lists-free-lists">2.4 ListHeads Lists (Free Lists)</a></li>
        <li><a href="#25-lookaside-lists">2.5 Lookaside Lists</a></li>
        <li><a href="#26-large-pool-allocations">2.6 Large Pool Allocations</a></li>
        <li><a href="#27-allocation-algorithm">2.7 Allocation Algorithm</a></li>
        <li><a href="#28-free-algorithm">2.8 Free Algorithm</a></li>
        <li><a href="#29-amd64x64-kernel-pool-changes">2.9 AMD64/x64 Kernel Pool Changes</a></li>
      </ul>
    </li>
    <li><a href="#3kernel-pool-attacks">3.Kernel Pool Attacks</a>
      <ul>
        <li><a href="#31-listentry-flink-overwrite">3.1 ListEntry Flink Overwrite</a></li>
        <li><a href="#32-lookaside-next-pointer-overwrite">3.2 Lookaside Next Pointer Overwrite</a></li>
        <li><a href="#33-pendingfrees-next-pointer-overwrite">3.3 PendingFrees Next Pointer Overwrite</a></li>
        <li><a href="#34-poolindex-overwrite">3.4 PoolIndex Overwrite</a></li>
        <li><a href="#35-quota-process-pointer-overwrite">3.5 Quota Process Pointer Overwrite</a></li>
      </ul>
    </li>
    <li><a href="#4case-study-cve-2010-1893">4.Case Study: CVE-2010-1893</a>
      <ul>
        <li><a href="#41-about-the-vulnerability">4.1 About the Vulnerability</a></li>
        <li><a href="#42-preparing-pool-memory">4.2 Preparing Pool Memory</a></li>
        <li><a href="#43-using-poolindex-overwrite">4.3 Using PoolIndex Overwrite</a></li>
      </ul>
    </li>
    <li><a href="#5kernel-pool-hardening">5.Kernel Pool Hardening</a>
      <ul>
        <li><a href="#51-listentry-flink-overwrite">5.1 ListEntry Flink Overwrite</a></li>
        <li><a href="#52-lookaside-next-pointer-overwrite">5.2 Lookaside Next Pointer Overwrite</a></li>
        <li><a href="#53-pendingfrees-next-pointer-overwrite">5.3 PendingFrees Next Pointer Overwrite</a></li>
        <li><a href="#54-poolindex-overwrite">5.4 PoolIndex Overwrite</a></li>
        <li><a href="#55-quota-process-pointer-overwrite">5.5 Quota Process Pointer Overwrite</a></li>
      </ul>
    </li>
    <li><a href="#6conclusion">6.Conclusion</a></li>
    <li><a href="#references">References</a></li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><blockquote>
<p><a href="https://dl.packetstormsecurity.net/papers/general/kernelpool-exploitation.pdf"target="_blank" rel="external nofollow noopener noreferrer">https://dl.packetstormsecurity.net/papers/general/kernelpool-exploitation.pdf</a>
<a href="https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf?source=post_page"target="_blank" rel="external nofollow noopener noreferrer">https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf?source=post_page</a>
<a href="https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf"target="_blank" rel="external nofollow noopener noreferrer">https://www.sstic.org/media/SSTIC2020/SSTIC-actes/pool_overflow_exploitation_since_windows_10_19h1/SSTIC2020-Article-pool_overflow_exploitation_since_windows_10_19h1-bayet_fariello.pdf</a></p>
</blockquote>
<p><strong>摘要</strong>：在Windows 7中，微软引入了safe unlinking技术来解决影响Windows内核的安全公告日益增多的问题。在从双向链表中删除条目之前，safe unlinking旨在通过验证相邻列表条目的指针来检测内存损坏。因此，攻击者不能轻易地利用通用技术来利用泄漏池溢出或其他泄漏池损坏漏洞。本文中，我们展示了尽管引入了安全措施，Windows 7仍然容易受到通用内核池(kernel pool)攻击的影响。特别是，我们展示了在某些条件下，池分配器可能无法安全地unlink空闲列表条目，从而允许攻击者破坏任意内存。为了防止这些攻击，我们提出了进一步加固和增强内核池安全性的方法。</p>
<p><strong>关键词</strong>：内核池，安全解链，利用</p>
<h2 id="1introduction" class="heading-element">
  <a href="#1introduction" class="heading-mark"></a>1.Introduction</h2><p>由于现代计算的复杂性，软件漏洞很难完全消除，因此供应商正在尽最大努力隔离和防止安全漏洞的利用。现代操作系统引入了DEP和ASLR等缓解措施，以应对各种常用的利用技术。然而，由于缓解措施未解决安全漏洞的根本原因，总会存在一些边界情况，这些措施可能不足以防范。例如，仅仅使用DEP可以轻松绕过返回导向编程（ROP）[15]。此外，利用功能强大的应用内嵌脚本引擎(application-embedded scripting engines)的新技术可能完全绕过DEP和ASLR [4]。</p>
<p>一种补充性的缓解措施是特权隔离(privilege isolation)。通过使用操作系统内置的安全机制对用户和进程施加限制，攻击者无法轻易访问和操纵受损系统中的系统文件和注册表信息。自Vista引入用户账户控制（UAC）以来，用户不再默认以管理员权限运行常规应用程序。此外，现代浏览器[2]和文档阅读器[13] [12]使用&quot;沙盒化(sandboxed)&ldquo;的渲染进程(render processes)来减轻解析库和布局引擎中安全漏洞的影响。反过来，这激励攻击者（以及研究人员）将他们的努力集中在特权提升攻击上。通过在最高特权环中执行任意代码，操作系统的安全性将被破坏。</p>
<blockquote>
<p>The kernel pool is analogous to the user-mode heap and was for many years susceptible to generic write-4 attacks abusing the unlink operation of doubly-linked lists [8][16]</p>
</blockquote>
<p>特权提升漏洞在大多数情况下是由操作系统内核或第三方驱动程序中的错误引起的。许多漏洞源于对动态分配的内核池内存的处理。内核池类似于用户模式堆，多年来容易受到滥用双向链表的解链操作的通用写入-4攻击的影响[8][16]。为了应对日益增多的内核漏洞，微软在Windows 7中引入了安全解链（safe unlinking）[3]。safe unlinking确保在unlink之前，对双向链表的空闲列表中相邻内存块的指针进行验证。</p>
<blockquote>
<p>This often starts with an arbitrary memory write or n-byte corruption at a chosen location
We also show that safe  unlinking, designed to remediate write-4 attacks, may under certain conditions fail to achieve its goals and allow an attacker to corrupt arbitrary memory</p>
</blockquote>
<p>攻击者在利用内核池损坏漏洞时的目标是最终在 ring 0 中执行任意代码。这通常以在所选位置进行任意内存写入或n字节损坏开始。在本文中，我们展示了尽管引入了安全措施，Windows 7中的内核池仍然容易受到通用攻击的影响。反过来，这些攻击可能允许攻击者完全破坏操作系统内核。我们还展示了为了纠正写入-4攻击而设计的safe  unlinking，在特定条件下可能无法达到其目标，并允许攻击者破坏任意内存。为了阻止所呈现的攻击，我们最终提出了进一步加固和增强内核池安全性的方法。</p>
<p>论文的其余部分按如下方式组织。第2节详细介绍了Windows 7（和Vista）内核池的内部结构和更改。第3节和第4节我们讨论并演示了影响Windows 7的实际内核池攻击。第5节我们讨论了对策并提出了加固内核池的方法。最后，在第6节中，我们对论文进行了总结。</p>
<h2 id="2kernel-pool-internals" class="heading-element">
  <a href="#2kernel-pool-internals" class="heading-mark"></a>2.Kernel Pool Internals</h2><p>在本节中，我们详细介绍了内核池管理结构和算法，这些结构和算法涉及内核池内存的分配和释放。了解内核池的行为对于正确评估其安全性和健壮性至关重要。
为了简洁起见，我们假设使用x86架构（32位）。然而，大多数结构适用于AMD64/x64架构（64位）。有关x86和x64架构之间内核池的显着差异将在第2.9节中讨论。</p>
<h3 id="21-non-uniform-memory-architecture" class="heading-element">
  <a href="#21-non-uniform-memory-architecture" class="heading-mark"></a>2.1 Non-Uniform Memory Architecture</h3><p>对于每个新版本的Windows，内存管理器都得到改进，以更好地支持非一致性内存体系结构（NUMA），这是一种用于现代多处理器系统的内存设计体系结构。NUMA将不同的内存模块分配给不同的处理器，使得本地内存可以更快地访问，而远程内存则访问速度较慢。处理器和内存被分组到较小的单元中，称为节点（nodes），由执行内核中的<code>KNODE</code>结构定义。</p>
<div class="highlight" id="id-1"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_KNODE</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x000*/</span> <span class="k">union</span> <span class="n">_SLIST_HEADER</span> <span class="n">PagedPoolSListHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x008*/</span> <span class="k">union</span> <span class="n">_SLIST_HEADER</span> <span class="n">NonPagedPoolSListHead</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x020*/</span> <span class="k">struct</span> <span class="n">_GROUP_AFFINITY</span> <span class="n">Affinity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x02C*/</span> <span class="n">ULONG32</span> <span class="n">ProximityId</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x030*/</span> <span class="n">UINT16</span> <span class="n">NodeNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x032*/</span> <span class="n">UINT16</span> <span class="n">PrimaryNodeNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x034*/</span> <span class="n">UINT8</span> <span class="n">MaximumProcessors</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x035*/</span> <span class="n">UINT8</span> <span class="n">Color</span><span class="p">;</span><span class="c1">//local memory address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="cm">/*0x036*/</span> <span class="k">struct</span> <span class="n">_flags</span> <span class="n">Flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x037*/</span> <span class="n">UINT8</span> <span class="n">NodePad0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x038*/</span> <span class="n">ULONG32</span> <span class="n">Seed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x03C*/</span> <span class="n">ULONG32</span> <span class="n">MmShiftedColor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x040*/</span> <span class="n">ULONG32</span> <span class="n">FreeCount</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x048*/</span> <span class="k">struct</span> <span class="n">_CACHED_KSTACK_LIST</span> <span class="n">CachedKernelStacks</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x060*/</span> <span class="n">LONG32</span> <span class="n">ParkLock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x064*/</span> <span class="n">ULONG32</span> <span class="n">NodePad1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x068*/</span> <span class="n">UINT8</span> <span class="n">_PADDING0_</span><span class="p">[</span><span class="mh">0x18</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">KNODE</span><span class="p">,</span> <span class="o">*</span><span class="n">PKNODE</span><span class="p">;</span></span></span></code></pre></div><p>在多节点系统（<code>nt!KeNumberNodes</code> &gt; 1）上，内存管理器将始终尝试从理想节点分配内存。因此，<code>KNODE</code>提供了有关本地内存位置的信息，存储在<code>Color</code>字段中。该值是一个数组索引，由分配和释放算法用于将节点与其首选池(preferred
pool)相关联。此外，<code>KNODE</code>为每个节点定义了四个单向链表的预留列表(lookaside lists)，用于空闲池页面(ree pool pages)（在第2.6节中讨论）。</p>
<h3 id="22-system-memory-pools" class="heading-element">
  <a href="#22-system-memory-pools" class="heading-mark"></a>2.2 System Memory Pools</h3><p>在系统初始化时，内存管理器根据系统节点的数量创建动态大小的内存池。每个池由一个池描述符定义（在第2.3节中讨论），这是一个管理结构，用于跟踪池的使用情况并定义池的属性，如内存类型。池内存有两种不同的类型：分页和非分页(paged and non-paged)。</p>
<p>分页池内存可以在任何进程上下文中分配和访问，但只能在<code>IRQL &lt; DPC/调度级别</code>下进行。正在使用的分页池数量由<code>nt!ExpNumberOfPagedPools</code>给出。在单处理器系统中，定义了四个（4个）分页池描述符，分别用索引1到4表示在<code>nt!ExpPagedPoolDescriptor</code>数组中。在多处理器系统中，每个节点定义了一个（1个）分页池描述符。在这两种情况下，还为原型池(prototype pools)/整页分配定义了额外的分页池描述符，用索引0在<code>nt!ExpPagedPoolDescriptor</code>中表示。因此，在大多数桌面系统中，定义了五个（5个）分页池描述符。</p>
<p>非分页池内存始终保证驻留在物理内存中。这对于在<code>IRQL &gt;= DPC/调度级别</code>下执行的线程（例如中断处理程序）是必需的，因为无法及时满足页面错误。当前正在使用的非分页池数量由<code>nt!ExpNumberOfNonPagedPools</code>给出。在单处理器系统中，<code>nt!PoolVector</code>数组的第一个索引指向非分页池描述符。在多处理器系统中，每个节点都有自己的非分页池描述符，由<code>nt!ExpNonPagedPoolDescriptor</code>数组索引。</p>
<p>此外，会话池内存（由win32k使用,session pool）用于会话空间的分配，对于每个用户 会话是唯一的。虽然非分页会话内存使用全局非分页池描述符，但分页会话池内存具有在<code>nt!MM_SESSION_SPACE</code>中定义的自己的池描述符。要获取会话池描述符，Windows 7会解析关联的<code>nt!EPROCESS</code>结构（当前执行线程的结构），以查找会话空间结构，然后找到嵌入的分页池描述符。</p>
<h3 id="23-pool-descriptor" class="heading-element">
  <a href="#23-pool-descriptor" class="heading-mark"></a>2.3 Pool Descriptor</h3><p>就像用户模式堆一样，每个内核池都需要一个管理结构。池描述符负责跟踪正在运行的分配数量、正在使用的页面以及有关池使用情况的其他信息。它还帮助系统跟踪可重用的池块。池描述符由以下结构（<code>nt!POOL_DESCRIPTOR</code>）定义。</p>
<div class="highlight" id="id-2"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_POOL_DESCRIPTOR</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x000*/</span> <span class="k">enum</span> <span class="n">_POOL_TYPE</span> <span class="n">PoolType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*0x004*/</span> <span class="k">struct</span> <span class="n">_KGUARDED_MUTEX</span> <span class="n">PagedLock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*0x004*/</span> <span class="n">ULONG32</span> <span class="n">NonPagedLock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x040*/</span> <span class="n">LONG32</span> <span class="n">RunningAllocs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x044*/</span> <span class="n">LONG32</span> <span class="n">RunningDeAllocs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x048*/</span> <span class="n">LONG32</span> <span class="n">TotalBigPages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x04C*/</span> <span class="n">LONG32</span> <span class="n">ThreadsProcessingDeferrals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x050*/</span> <span class="n">ULONG32</span> <span class="n">TotalBytes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x054*/</span> <span class="n">UINT8</span> <span class="n">_PADDING0_</span><span class="p">[</span><span class="mh">0x2C</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x080*/</span> <span class="n">ULONG32</span> <span class="n">PoolIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x084*/</span> <span class="n">UINT8</span> <span class="n">_PADDING1_</span><span class="p">[</span><span class="mh">0x3C</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x0C0*/</span> <span class="n">LONG32</span> <span class="n">TotalPages</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x0C4*/</span> <span class="n">UINT8</span> <span class="n">_PADDING2_</span><span class="p">[</span><span class="mh">0x3C</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x100*/</span> <span class="n">VOID</span> <span class="o">**</span><span class="n">PendingFrees</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x104*/</span> <span class="n">LONG32</span> <span class="n">PendingFreeDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x108*/</span> <span class="n">UINT8</span> <span class="n">_PADDING3_</span><span class="p">[</span><span class="mh">0x38</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/*0x140*/</span> <span class="k">struct</span> <span class="n">_LIST_ENTRY</span> <span class="n">ListHeads</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">POOL_DESCRIPTOR</span><span class="p">,</span> <span class="o">*</span><span class="n">PPOOL_DESCRIPTOR</span><span class="p">;</span></span></span></code></pre></div><p>池描述符包含内存管理器使用的几个重要列表。延迟释放列表由<code>PendingFrees</code>指针指向，它是一个单链表，用于存放等待释放的池块。该列表在第2.8节中有详细解释。<code>ListHeads</code>是一个双链表数组，用于存放相同大小的空闲池块。与延迟释放列表不同，<code>ListHeads</code>列表中的块已经被释放，内存管理器随时可以对其进行分配。我们在下一节中讨论<code>ListHeads</code>。</p>
<h3 id="24-listheads-lists-free-lists" class="heading-element">
  <a href="#24-listheads-lists-free-lists" class="heading-mark"></a>2.4 ListHeads Lists (Free Lists)</h3><p><code>ListHeads</code>列表，或称为空闲列表，按照每个8字节的粒度(granularity)大小排序，并用于最多4080字节的分配。空闲块通过块大小索引到<code>ListHeads</code>数组中，块大小的计算方式是将请求的字节数向上舍入为8的倍数，然后除以8，即<code>BlockSize = (NumberOfBytes+0xF) &gt;&gt; 3</code>。这种舍入是为了为池头保留空间，池头是位于所有池块之前的结构。在x86 Windows上，池头的定义如下。</p>
<div class="highlight" id="id-3"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_POOL_HEADER</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x000*/</span> <span class="n">UINT16</span> <span class="nl">PreviousSize</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x000*/</span> <span class="n">UINT16</span> <span class="nl">PoolIndex</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x002*/</span> <span class="n">UINT16</span> <span class="nl">BlockSize</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x002*/</span> <span class="n">UINT16</span> <span class="nl">PoolType</span> <span class="p">:</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">};</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="n">Ulong1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="k">union</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/*0x004*/</span> <span class="n">ULONG32</span> <span class="n">PoolTag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">struct</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x004*/</span> <span class="n">UINT16</span> <span class="n">AllocatorBackTraceIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/*0x006*/</span> <span class="n">UINT16</span> <span class="n">PoolTagHash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">POOL_HEADER</span><span class="p">,</span> <span class="o">*</span><span class="n">PPOOL_HEADER</span><span class="p">;</span></span></span></code></pre></div><p>池头包含了<strong>分配</strong>和<strong>释放算法</strong>正常运行所需的信息。<code>PreviousSize</code>表示前一个池块的块大小。由于内存管理器始终尝试通过合并相邻的空闲块来减少碎片化，因此通常用于定位前一个块的池头。<code>PreviousSize</code>也可能为零，这意味着池块位于池页面的开头。</p>
<p><code>PoolIndex</code>提供了对应的池描述符数组（例如<code>nt!ExpPagedPoolDescriptor</code>）的索引。它被释放算法使用，以确保池块被释放到正确的池描述符<code>ListHeads</code>中。在第3.4节中，我们展示了攻击者如何破坏这个值，以将池头损坏（如池溢出）扩展为任意内存损坏。</p>
<p>正如其名称所示，<code>PoolType</code>定义了块的池类型。然而，它也指示了一个块是忙碌还是空闲。如果一个块是空闲的，<code>PoolType</code>被设置为零。另一方面，如果一个块是忙碌的，<code>PoolType</code>被设置为其描述符的池类型（在下面显示的<code>POOL_TYPE</code>枚举中的一个值）与正在使用的池位掩码进行按位或运算。这个位掩码在Vista及更高版本上设置为2，而在XP/2003上设置为4。例如，在Vista和Windows 7上，对于一个忙碌的分页池块，<code>PoolType = PagedPool | 2 = 3</code>。</p>
<div class="highlight" id="id-4"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="n">_POOL_TYPE</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPool</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>                          <span class="cm">/*0x0*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">PagedPool</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>                             <span class="cm">/*0x1*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolMustSucceed</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>               <span class="cm">/*0x2*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">DontUseThisType</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>                       <span class="cm">/*0x3*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolCacheAligned</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>              <span class="cm">/*0x4*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">PagedPoolCacheAligned</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>                 <span class="cm">/*0x5*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolCacheAlignedMustS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>         <span class="cm">/*0x6*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">MaxPoolType</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>                           <span class="cm">/*0x7*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolSession</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>                  <span class="cm">/*0x20*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolMustSucceedSession</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>       <span class="cm">/*0x22*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">DontUseThisTypeSession</span> <span class="o">=</span> <span class="mi">35</span><span class="p">,</span>               <span class="cm">/*0x23*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolCacheAlignedSession</span> <span class="o">=</span> <span class="mi">36</span><span class="p">,</span>      <span class="cm">/*0x24*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">PagedPoolCacheAlignedSession</span> <span class="o">=</span> <span class="mi">37</span><span class="p">,</span>         <span class="cm">/*0x25*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">NonPagedPoolCacheAlignedMustSSession</span> <span class="o">=</span> <span class="mi">38</span><span class="p">,</span> <span class="cm">/*0x26*/</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">POOL_TYPE</span><span class="p">,</span> <span class="o">*</span><span class="n">PPOOL_TYPE</span><span class="p">;</span></span></span></code></pre></div><p>如果一个池块是空闲的，并且在<code>ListHeads</code>列表中，它的池头紧跟着一个<code>LIST_ENTRY</code>结构。因此，单个块大小（8字节）的块不由<code>ListHeads</code>维护，因为它们不足以容纳该结构。</p>
<div class="highlight" id="id-5"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_LIST_ENTRY</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x000*/</span> <span class="k">struct</span> <span class="n">_LIST_ENTRY</span> <span class="o">*</span><span class="n">Flink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x004*/</span> <span class="k">struct</span> <span class="n">_LIST_ENTRY</span> <span class="o">*</span><span class="n">Blink</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">LIST_ENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">PLIST_ENTRY</span><span class="p">;</span></span></span></code></pre></div><p><code>LIST_ENTRY</code> 结构用于将池块连接到双向链表上。历史上，它一直是利用内存损坏漏洞的目标，无论是在用户模式堆[5]还是内核池[8][16]中，主要是由于众所周知的&quot;write-4&quot;利用技术(在unlink过程中中，覆盖<code>LIST_ENTRY</code>结构可能会导致任意值（指针）被写入内存中的任意位置)。微软在Windows XP SP2 [5]发布时解决了用户模式堆中的<code>LIST_ENTRY</code>攻击问题，并在Windows 7 [3]中类似地解决了内核池中的问题。</p>
<h3 id="25-lookaside-lists" class="heading-element">
  <a href="#25-lookaside-lists" class="heading-mark"></a>2.5 Lookaside Lists</h3><p>内核使用单向链表（LIFO）的<code>lookaside</code>列表来更快地分配和释放小的池块。它们被设计用于高度并发的代码，并且在添加和删除条目时使用原子比较和交换指令。为了更好地利用CPU缓存，<code>lookaside列</code>表在处理器控制块（<code>KPRCB</code>）中针对每个处理器进行定义。<code>KPRCB</code>结构保存了分页（<code>PPPagedLookasideLis</code>t）和非分页（<code>PPNPagedLookasideList</code>）分配的<code>lookaside</code>列表，以及用于频繁请求的固定大小分配（例如I/O请求包和内存描述符列表）的特殊专用<code>lookaside</code>列表（<code>PPLookasideList</code>）。</p>
<div class="highlight" id="id-6"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_KPRCB</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x5A0*/</span> <span class="k">struct</span> <span class="n">_PP_LOOKASIDE_LIST</span> <span class="n">PPLookasideList</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x620*/</span> <span class="k">struct</span> <span class="n">_GENERAL_LOOKASIDE_POOL</span> <span class="n">PPNPagedLookasideList</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0xF20*/</span> <span class="k">struct</span> <span class="n">_GENERAL_LOOKASIDE_POOL</span> <span class="n">PPPagedLookasideList</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">KPRCB</span><span class="p">,</span> <span class="o">*</span><span class="n">PKPRCB</span><span class="p">;</span></span></span></code></pre></div><p>对于分页和非分页的<code>lookaside</code>列表，最大块大小为0x20（32字节）。因此，每种类型有32个独特的<code>lookaside</code>列表。每个<code>lookaside</code>列表由下面显示的<code>GENERAL_LOOKASIDE_POOL</code>结构定义。</p>
<div class="highlight" id="id-7"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GENERAL_LOOKASIDE_POOL</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x000*/</span> <span class="k">union</span> <span class="n">_SLIST_HEADER</span> <span class="n">ListHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x000*/</span> <span class="k">struct</span> <span class="n">_SINGLE_LIST_ENTRY</span> <span class="n">SingleListHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x008*/</span> <span class="n">UINT16</span> <span class="n">Depth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x00A*/</span> <span class="n">UINT16</span> <span class="n">MaximumDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x00C*/</span> <span class="n">ULONG32</span> <span class="n">TotalAllocates</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x010*/</span> <span class="n">ULONG32</span> <span class="n">AllocateMisses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x010*/</span> <span class="n">ULONG32</span> <span class="n">AllocateHits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x014*/</span> <span class="n">ULONG32</span> <span class="n">TotalFrees</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x018*/</span> <span class="n">ULONG32</span> <span class="n">FreeMisses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x018*/</span> <span class="n">ULONG32</span> <span class="n">FreeHits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x01C*/</span> <span class="k">enum</span> <span class="n">_POOL_TYPE</span> <span class="n">Type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x020*/</span> <span class="n">ULONG32</span> <span class="n">Tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x024*/</span> <span class="n">ULONG32</span> <span class="n">Size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x028*/</span> <span class="n">PVOID</span> <span class="n">AllocateEx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x028*/</span> <span class="n">PVOID</span> <span class="n">Allocate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x02C*/</span> <span class="n">PVOID</span> <span class="n">FreeEx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x02C*/</span> <span class="n">PVOID</span> <span class="n">Free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x030*/</span> <span class="k">struct</span> <span class="n">_LIST_ENTRY</span> <span class="n">ListEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x038*/</span> <span class="n">ULONG32</span> <span class="n">LastTotalAllocates</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x03C*/</span> <span class="n">ULONG32</span> <span class="n">LastAllocateMisses</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x03C*/</span> <span class="n">ULONG32</span> <span class="n">LastAllocateHits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x040*/</span> <span class="n">ULONG32</span> <span class="n">Future</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">GENERAL_LOOKASIDE_POOL</span><span class="p">,</span> <span class="o">*</span><span class="n">PGENERAL_LOOKASIDE_POOL</span><span class="p">;</span></span></span></code></pre></div><p>在这个结构中，<code>SingleListHead.Next</code>指向单向链表上第一个空闲的池块。<code>lookaside</code>列表的大小由<code>Depth</code>的值限制，该值由平衡集管理器（balance set manager，平衡集管理器是一个系统线程，执行<code>nt!KeBalanceSetManager</code>函数，定期处理工作项并调整<code>lookaside</code>列表的大小。）根据对<code>lookaside</code>列表的命中和未命中次数进行定期调整。因此，一个经常使用的<code>lookaside</code>列表的<code>Depth</code>值会比一个不经常使用的列表的<code>Depth</code>值大。初始的<code>Depth</code>值为4（<code>nt!ExMinimumLookasideDepth</code>），最大值为<code>MaximumDepth</code>（256）。如果一个<code>lookaside</code>列表已满，池块将被释放到相应的<code>ListHeads</code>列表中。</p>
<p>还为会话池定义了<code>lookaside</code>列表。分页会话池分配使用在会话空间中定义的单独的<code>lookaside</code>列表（<code>nt!ExpSessionPoolLookaside</code>）。每个会话的<code>lookaside</code>列表的最大块大小由<code>nt!ExpSessionPoolSmallLists</code>设置为0x19。会话池的<code>lookaside</code>列表使用与<code>GENERAL_LOOKASIDE_POOL</code>相同的<code>GENERAL_LOOKASIDE</code>结构，但具有额外的填充。对于非分页会话池分配，则使用先前讨论的非分页每个处理器的<code>lookaside</code>列表。</p>
<p>如果设置了热/冷页面分离的池标志（<code>nt!ExpPoolFlags &amp; 0x100</code>，hot/cold page separation pool），则禁用池块的<code>lookaside</code>列表。该标志在系统启动期间设置，以提高速度并减少内存占用。一个定时器（在<code>nt!ExpBootFinishedTimer</code>中设置）在启动后的2分钟内关闭热/冷页面分离。</p>
<h3 id="26-large-pool-allocations" class="heading-element">
  <a href="#26-large-pool-allocations" class="heading-mark"></a>2.6 Large Pool Allocations</h3><p>池描述符<code>ListHeads</code>维护小于一页的块。大于4080字节（需要一页或更多）的池分配由<code>nt!ExpAllocateBigPool</code>处理。该函数调用<code>nt!MiAllocatePoolPages</code>，即池页分配器(pool page allocator)，将请求的大小舍入到最近的页大小。在大型池分配之后，会立即放置一个块大小为1且前一个大小为0的“碎片”(frag)块，以便池分配器可以利用剩余的页面片段。多余的字节随后放回到相应池描述符的<code>ListHeads</code>列表的末尾。</p>
<p>回顾第2.1节，每个节点（由<code>KNODE</code>定义）与4个单向链表相关联。这些链表由池页分配器用于快速处理小页面计数的请求。对于分页内存，<code>KNODE</code>定义了一个<code>lookaside</code>列表（<code>PagedPoolSListHead</code>）用于单页分配。对于非分页分配，定义了<code>lookaside</code>列表（<code>NonPagedPoolSListHead[3]</code>）用于页面计数为1、2和3。池页<code>lookaside</code>列表的大小由系统中存在的物理页面数量决定。</p>
<p>如果无法使用lookaside列表，将使用分配位图(allocation bitmap)来获取所请求的池页。位图（在<code>RTL_BITMAP</code>中定义）是一个位数组，指示哪些内存页面正在使用，并且为每个主要池类型创建一个位图。它会搜索第一个包含所请求数量的未使用页面的索引。对于分页池，位图在<code>MM_PAGED_POOL_INFO</code>结构中定义，由<code>nt!MmPagedPoolInfo</code>指向。对于非分页池，位图由<code>nt!MiNonPagedPoolBitMap</code>指向。对于会话池，位图在<code>MM_SESSION_SPACE</code>结构中定义。</p>
<p>对于大多数大型池分配，<code>nt!ExAllocatePoolWithTag</code>将请求额外的4字节（在x64上为8字节）来存储分配大小，存放在池体的末尾。在释放分配时（在<code>ExFreePoolWithTag</code>中），将检查该值，以捕获可能的池溢出情况。</p>
<h3 id="27-allocation-algorithm" class="heading-element">
  <a href="#27-allocation-algorithm" class="heading-mark"></a>2.7 Allocation Algorithm</h3><p>为了分配池内存，内核模块和第三方驱动程序调用由执行内核导出的<code>ExAllocatePoolWithTag</code>（或其任何包装函数）。该函数首先尝试使用<code>lookaside</code>列表，然后使用<code>ListHeads</code>列表，如果无法返回池块，则从池页分配器请求一个页面。以下伪代码大致概述了其实现过程。</p>
<div class="highlight" id="id-8"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">PVOID</span> <span class="nf">ExAllocatePoolWithTag</span><span class="p">(</span><span class="n">POOL_TYPE</span> <span class="n">PoolType</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">NumberOfBytes</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果大小超过4080字节，则调用池页分配器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">NumberOfBytes</span> <span class="o">&gt;</span> <span class="mh">0xff0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 nt!ExpAllocateBigPool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 尝试使用 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">PoolType</span> <span class="o">&amp;</span> <span class="n">PagedPool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">PoolType</span> <span class="o">&amp;</span> <span class="n">SessionPool</span> <span class="o">&amp;&amp;</span> <span class="n">NumberOfBytes</span> <span class="o">&lt;=</span> <span class="mh">0x19</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 尝试会话分页 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">NumberOfBytes</span> <span class="o">&lt;=</span> <span class="mh">0x20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 尝试每个处理器的分页 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 锁定分页池描述符（循环或本地节点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">// NonPagedPool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">NumberOfBytes</span> <span class="o">&lt;=</span> <span class="mh">0x20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 尝试每个处理器的非分页 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 锁定非分页池描述符（本地节点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 尝试使用 listheads 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">NumberOfBytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ListHeads</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">Flink</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">ListHeads</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>             <span class="c1">// 空的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">continue</span><span class="p">;</span> <span class="c1">// 尝试下一个块大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 安全地取消链接 ListHeads[n].Flink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果大于所需大小，则拆分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 返回块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 未找到块，调用 nt!MiAllocatePoolPages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 拆分页面并返回块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div><p>如果从<code>ListHeads[n]</code>列表返回的块大于请求的大小，则会拆分该块。为了减少碎片化，分配器返回的超大块的部分取决于其相对于页面的位置。如果块与页面对齐，请求的大小将从块的前部分分配。如果块不与页面对齐，请求的大小将从块的后部分分配。无论哪种方式，拆分块的剩余（未使用）片段将放在适当的<code>ListHeads</code>列表的尾部。</p>
<h3 id="28-free-algorithm" class="heading-element">
  <a href="#28-free-algorithm" class="heading-mark"></a>2.8 Free Algorithm</h3><p><code>ExFreePoolWithTag</code>函数实现的释放算法会检查要释放的块的池头，并将其释放到相应的列表中。为了减少碎片化，它还尝试合并相邻的空闲块。以下伪代码展示了算法的工作原理。</p>
<div class="highlight" id="id-9"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">VOID</span> <span class="nf">ExFreePoolWithTag</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">Entry</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">Tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">PAGE_ALIGNED</span><span class="p">(</span><span class="n">Entry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用 nt!MiFreePoolPages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">!=</span> <span class="n">NextEntry</span><span class="o">-&gt;</span><span class="n">PreviousSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">BugCheckEx</span><span class="p">(</span><span class="n">BAD_POOL_HEADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">PoolType</span> <span class="o">&amp;</span> <span class="n">SessionPagedPool</span> <span class="o">&amp;&amp;</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">&lt;=</span> <span class="mh">0x19</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 放入会话池的 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">&lt;=</span> <span class="mh">0x20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">PoolType</span> <span class="o">&amp;</span> <span class="n">PagedPool</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 放入每个处理器的分页 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="c1">// NonPagedPool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 放入每个处理器的非分页 lookaside 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 成功时返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ExpPoolFlags</span> <span class="o">&amp;</span> <span class="n">DELAY_FREE</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="c1">// 0x200
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">PendingFreeDepth</span> <span class="o">&gt;=</span> <span class="mh">0x20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 调用 nt!ExDeferredFreePool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将 Entry 添加到 PendingFrees 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FREE</span><span class="p">(</span><span class="n">NextEntry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">PAGE_ALIGNED</span><span class="p">(</span><span class="n">NextEntry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 安全地取消链接下一个条目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 将下一个条目与当前块合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FREE</span><span class="p">(</span><span class="n">PreviousEntry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 安全地取消链接上一个条目
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 将上一个条目与当前块合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FULL_PAGE</span><span class="p">(</span><span class="n">Entry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 调用 nt!MiFreePoolPages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将 Entry 插入到 ListHeads[BlockSize - 1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p><code>DELAY_FREE</code>池标志（<code>nt!ExpPoolFlags ＆ 0x200</code>）启用了一种性能优化，可以一次释放多个池分配，以分摊池获取和释放的开销。这个机制在[11]中简要提到，并且在Windows XP SP2或更高版本中启用，如果可用物理页面的数量（<code>nt!MmNumberOfPhysicalPages</code>）大于或等于0x1fc00(大致翻译为，在IA-32和AMD64架构上，这大约相当于508兆字节的RAM。)。当使用时，每次调用<code>ExFreePoolWithTag</code>时，要释放的块都会附加到每个池描述符特定的<code>PendingFrees</code>列表中。如果该列表包含32个或更多的块（由<code>PendingFreeDepth</code>确定），则会在调用<code>ExDeferredFreePool</code>时对其进行处理。该函数遍历每个条目，并将其释放到相应的<code>ListHeads</code>列表中，如下面的伪代码所示：</p>
<div class="highlight" id="id-10"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">VOID</span> <span class="nf">ExDeferredFreePool</span><span class="p">(</span><span class="n">PPOOL_DESCRIPTOR</span> <span class="n">PoolDesc</span><span class="p">,</span> <span class="n">BOOLEAN</span> <span class="n">bMultipleThreads</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nf">each</span> <span class="p">(</span><span class="n">Entry</span> <span class="n">in</span> <span class="n">PendingFrees</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FREE</span><span class="p">(</span><span class="n">NextEntry</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">PAGE_ALIGNED</span><span class="p">(</span><span class="n">NextEntry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// safe unlink next entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// merge next with current chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FREE</span><span class="p">(</span><span class="n">PreviousEntry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// safe unlink previous entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// merge previous with current chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">IS_FULL_PAGE</span><span class="p">(</span><span class="n">Entry</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// add to full page list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// insert Entry to ListHeads[BlockSize - 1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nf">each</span> <span class="p">(</span><span class="n">page</span> <span class="n">in</span> <span class="n">full</span> <span class="n">page</span> <span class="n">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// call nt!MiFreePoolPages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>释放到<code>lookaside</code>和池描述符<code>ListHeads</code>的块总是放在相应列表的前面。这个规则的例外是被拆分块的剩余片段，它们被放在列表的尾部。当内存管理器返回大于请求大小的块（如第2.7节所述）时，块会被拆分，比如在<code>ExpBigPoolAllocation</code>中拆分的整页和在<code>ExAllocatePoolWithTag</code>中拆分的<code>ListHeads</code>条目。为了尽可能频繁地使用CPU缓存，分配总是从最近使用的块中进行，从相应列表的前面开始。</p>
<h3 id="29-amd64x64-kernel-pool-changes" class="heading-element">
  <a href="#29-amd64x64-kernel-pool-changes" class="heading-mark"></a>2.9 AMD64/x64 Kernel Pool Changes</h3><p>尽管x64 Windows支持更大的物理地址空间，但对内核池没有引入任何重大更改。然而，为了适应指针宽度的变化，块大小的粒度增加到16字节，计算公式为<code>BlockSize = (NumberOfBytes+0x1F) &gt;&gt; 4</code>。为了反映这个变化，池头也相应地进行了更新。</p>
<div class="highlight" id="id-11"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_POOL_HEADER</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="nl">PreviousSize</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="nl">PoolIndex</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="nl">BlockSize</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="nl">PoolType</span> <span class="p">:</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x000*/</span> <span class="n">ULONG32</span> <span class="n">Ulong1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*0x004*/</span> <span class="n">ULONG32</span> <span class="n">PoolTag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*0x008*/</span> <span class="k">struct</span> <span class="n">_EPROCESS</span> <span class="o">*</span><span class="n">ProcessBilled</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x008*/</span> <span class="n">UINT16</span> <span class="n">AllocatorBackTraceIndex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x00A*/</span> <span class="n">UINT16</span> <span class="n">PoolTagHash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="cm">/*0x00C*/</span> <span class="n">UINT8</span> <span class="n">_PADDING0_</span><span class="p">[</span><span class="mh">0x4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">POOL_HEADER</span><span class="p">,</span> <span class="o">*</span><span class="n">PPOOL_HEADER</span><span class="p">;</span></span></span></code></pre></div><p>由于块大小粒度的变化，<code>PreviousSize</code>和<code>BlockSize</code>都被减小为8位。因此，池描述符<code>ListHeads</code>保存了256个双向链表，而不是x86上的512个。这也允许将一个额外的位分配给<code>PoolIndex</code>，因此在x64上可以支持256个节点（池描述符），而在x86上只能支持128个。此外，池头扩展为16字节，并包括用于配额管理的<code>ProcessBilled</code>指针，用于标识为分配而计费的进程。在x86上，这个指针存储在池体的最后四个字节中。我们在第3.5节中讨论了利用配额进程指针的攻击。</p>
<h2 id="3kernel-pool-attacks" class="heading-element">
  <a href="#3kernel-pool-attacks" class="heading-mark"></a>3.Kernel Pool Attacks</h2><p>在本节中，我们讨论了对Windows 7内核池的几种实际攻击。首先，在第3.1节中，我们展示了对<code>LIST_ENTRY</code>结构的攻击，该攻击涉及对<code>ListHeads</code>池块进行(un)safe unlinking操作。在第3.2节和第3.3节中，我们分别展示了对单向链接的<code>lookaside</code>列表和延迟释放列表的攻击。在第3.4节中，我们介绍了对被释放的分配块的池头的攻击，最后，在第3.5节中，我们展示了对配额计费池分配(quota charged pool alloca)的攻击。</p>
<h3 id="31-listentry-flink-overwrite" class="heading-element">
  <a href="#31-listentry-flink-overwrite" class="heading-mark"></a>3.1 ListEntry Flink Overwrite</h3><p>为了解决对内核池溢出的通用利用，Windows 7执行安全解链操作，以验证<code>ListHeads</code>列表中池块的<code>LIST_ENTRY</code>指针。然而，在从<code>ListHeads[n]</code>（给定块大小）分配池块时，算法验证的是<code>ListHeads[n]</code>的<code>LIST_ENTRY</code>结构，而不是正在unlink的实际块的结构。因此，覆盖一个空闲块中的前向链接可能会导致<code>ListHeads[n]</code>的地址被写入到攻击者控制的地址中（见图1）。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816133051141.png" style="--width: 1152px;--aspect-ratio: 1152 / 670;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>这种攻击需要目标<code>ListHeads[n]</code>列表上至少有两个空闲块。否则，<code>ListHeads[n].Blink</code>会验证被解链块的前向链接。在示例1中，<code>ListHeads</code>列表上的一个池块的前向链接已被攻击者选择的地址破坏。接着，当这个块在<code>ExAllocatePoolWithTag</code>中被分配时，算法会尝试将<code>ListHeads[n]</code>的地址（esi）写入到攻击者控制的地址（eax）处<code>LIST_ENTRY</code>结构的后向链接。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816134801644.png" style="--width: 791px;--aspect-ratio: 791 / 301;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>尽管从用户模式上很难确定esi的值，但有时可以推断出它的值。例如，如果只定义了一个非分页池（如2.2节所讨论的），esi将指向<code>ntoskrnl</code>数据段中的一个固定位置（<code>nt!NonPagedPoolDescriptor</code>）。如果池描述符是从内存中分配的，可以根据定义的池内存范围推断出它的位置。因此，攻击者可以通过覆盖重要的全局变量[14]或内核对象指针[6]（例如通过部分指针覆盖）来实现任意代码执行。</p>
<p>攻击者还可以利用覆写中的用户模式指针将任意写扩展为完全受控的内核分配。这是因为在解链受损的块后，<code>ListHeads[n].Flink</code>会被更新为指向下一个空闲块（攻击者控制的指针）。由于攻击者提供的地址的后向链接已被更新为指向<code>ListHeads[n]</code>，池分配器可以安全地从空闲列表中unlink用户模式指针，因此不会出现问题。</p>
<h3 id="32-lookaside-next-pointer-overwrite" class="heading-element">
  <a href="#32-lookaside-next-pointer-overwrite" class="heading-mark"></a>3.2 Lookaside Next Pointer Overwrite</h3><p><code>Lookaside</code>列表被设计为快速和轻量级，因此不像双向链表的<code>ListHeads</code>列表那样引入相同的一致性检查。作为单链表，<code>lookaside</code>列表上的每个条目都保存着指向下一个条目的指针。由于没有对这些指针的有效性进行检查，攻击者可以利用池损坏漏洞来迫使池分配器返回一个任意地址以检索下一个空闲的<code>lookaside</code>块。这反过来可能允许攻击者破坏任意的内核内存。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135310282.png" style="--width: 898px;--aspect-ratio: 898 / 657;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>正如在第2.5节中讨论的那样，内存管理器在池块和池页面上都使用了<code>lookaside</code>列表。对于<code>lookaside</code>池块，<code>Next</code>指针直接跟随8字节的池头（<code>POOL_HEADER</code>）。因此，覆写Next指针最多需要在x86上进行12字节的溢出。为了将池块释放到<code>lookaside</code>列表中，必须满足以下条件：</p>
<ul>
<li>对于（分页/非分页）池块，<code>BlockSize &lt;= 0x20</code></li>
<li>对于分页会话池块，<code>BlockSize &lt;= 0x19</code></li>
<li>目标BlockSize的lookaside列表未满</li>
<li>未使用热/冷页面分离（<code>ExpPoolFlags &amp; 0x100</code>）</li>
</ul>
<p>为了将<code>lookaside Next</code>指针的损坏扩展为n字节的任意内存覆写，必须进行目标块大小的分配，直到返回被损坏的指针（图2）。此外，必须在一定程度上控制分配块的内容，以影响用于覆写的数据。对于分页池的分配，像<code>NtCreateSymbolicLinkObject</code>这样的本机API提供了一种方便的方式，可以用几乎任意组合的字节来填充任意大小的块。这样的API还可以用于对池内存布局进行碎片整理和操作，以控制可利用的原语(primitives)，如未初始化的指针和双重释放。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135451293.png" style="--width: 857px;--aspect-ratio: 857 / 676;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>与<code>lookaside</code>池块不同，<code>lookaside</code>池页面（图3）在偏移null处存储Next指针，因为它们没有与之关联的池头。如果满足以下条件，分配的池页面将被释放到<code>lookaside</code>列表中：</p>
<ul>
<li>对于分页池页面，<code>NumberOfPages = 1</code></li>
<li>对于非分页池页面，<code>NumberOfPages &lt;= 3</code></li>
<li>目标页面计数的lookaside列表未满</li>
</ul>
<p>当内存管理器需要请求额外的池内存时（无法从<code>ListHeads</code>或<code>lookaside</code>列表中获得），<code>nt!MiAllocatePoolPages</code>会返回池页面。由于这通常由许多并发的系统线程执行，为了将溢出位置放置在<code>lookaside</code>列表上的空闲池页面旁边，需要操作内核池布局，这显然不容易实现。另一方面，当使用<code>lookaside</code>池块时，可以使用不经常请求的块大小值，以更精细地控制内存布局。这可以通过检查<code>lookaside</code>管理结构中的<code>TotalAllocates</code>值来实现。</p>
<h3 id="33-pendingfrees-next-pointer-overwrite" class="heading-element">
  <a href="#33-pendingfrees-next-pointer-overwrite" class="heading-mark"></a>3.3 PendingFrees Next Pointer Overwrite</h3><p>回顾第2.8节，等待释放的池条目存储在单向链接的<code>PendingFrees</code>列表中。在遍历这些列表时，不进行任何检查，因此攻击者可以利用池损坏漏洞来破坏<code>PendingFrees</code>列表条目的<code>Next</code>指针。这将使攻击者能够将任意地址释放到所选的池描述符<code>ListHeads</code>列表中，并可能控制后续池分配的内存（图4）。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816135812648.png" style="--width: 918px;--aspect-ratio: 918 / 693;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>攻击延迟释放列表的一个显著限制是内核池非常频繁地处理该列表（每32次释放一次）。实际上，数百个线程可以被调度到同一个内核池，并且在多核机器上可以并行处理(每个池描述符都实现了一个锁，因此两个线程不会同时对同一个空闲列表进行操作。)。因此，一个被池溢出攻击目标的块很可能已经从延迟释放列表中移除，并放置在<code>ListHeads</code>列表中。出于这个原因，我们几乎无法认为这种攻击是实际可行的。然而，由于某些池描述符的使用频率较低（如会话池描述符），在某些情况下，对延迟释放列表的攻击可能是可行的。</p>
<h3 id="34-poolindex-overwrite" class="heading-element">
  <a href="#34-poolindex-overwrite" class="heading-mark"></a>3.4 PoolIndex Overwrite</h3><p>如果为给定的池类型定义了多个池描述符，池块的<code>PoolIndex</code>表示与关联的池描述符数组的索引。因此，在处理<code>ListHeads</code>条目时，池块总是被释放到其正确的池描述符中。然而，由于验证不足，一个格式错误的<code>PoolIndex</code>可能会触发越界的数组解引用(间接引用,dereference)，并随后允许攻击者覆盖任意内核内存。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140058293.png" style="--width: 1112px;--aspect-ratio: 1112 / 706;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>对于分页池，<code>PoolIndex</code>始终表示分页池描述符数组（<code>nt!ExpPagedPoolDescriptor</code>）中的索引。在调试版本中(On checked builds)，通过与<code>nt!ExpNumberOfPagedPools</code>进行比较，验证索引值以防止越界数组访问。然而，在免费版本中(on free (retail) builds)，索引没有进行验证。对于非分页池（non-paged pools），只有在NUMA感知系统中存在多个节点时，<code>PoolIndex</code>才表示对<code>nt!ExpNonPagedPoolDescriptor</code>的索引。同样，在免费版本中，<code>PoolIndex</code>没有进行验证。</p>
<p>一个格式错误的<code>PoolIndex</code>（只需要一个2字节的池溢出）可能会导致一个已分配的池块被释放到一个空指针池描述符（图5）。通过映射虚拟的空页，攻击者可以完全控制池描述符及其<code>ListHeads</code>条目。反过来，这可能允许攻击者在链接到列表时将池块的地址写入任意地址。这是因为当前位于前面的块的Blink会被更新为释放的块的地址，即<code>ListHeads[n].Flink-&gt;Blink = FreedChunk</code>。值得注意的是，由于释放的块没有返回到任何真实的池描述符，所以没有必要清理（删除陈旧的条目等）内核池。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140623402.png" style="--width: 1129px;--aspect-ratio: 1129 / 771;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>如果启用了延迟池释放（如2.8节所述），可以通过创建一个虚假的<code>PendingFrees</code>列表（图6）来实现类似的效果。在这种情况下，列表上的第一个条目将指向一个由攻击者控制的地址。此外，池描述符中的<code>PendingFreeDepth</code>的值将大于或等于0x20，以触发对<code>PendingFrees</code>列表的处理。</p>
<p>示例2演示了如何通过<code>PoolIndex</code>覆写可能导致将用户控制的页面地址（eax）写入任意目标地址（esi）。为了执行任意代码，攻击者可以利用这种方法，将一个不经常使用的内核函数指针用用户模式页面地址覆写，并从相同的进程上下文触发其执行。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816140803498.png" style="--width: 1125px;--aspect-ratio: 1125 / 434;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>如果还覆写了块的<code>PoolType</code>（例如将其设置为<code>PagedPool</code>），<code>PoolIndex</code>覆写攻击可以应用于任何池类型。由于这还需要覆写<code>BlockSize</code>，因此攻击者必须要么知道溢出块的大小，要么在其中创建一个嵌入的虚假边界块。这是必需的，因为释放算法会检查<code>FreedBlock-&gt;BlockSize = NextBlock-&gt;PreviousSize</code>是否成立。此外，块的大小应大于0x20，以避免<code>lookaside</code>列表（它们忽略<code>PoolIndex</code>）。但请注意，嵌入的池块可能会破坏块数据中的重要字段或指针。</p>
<h3 id="35-quota-process-pointer-overwrite" class="heading-element">
  <a href="#35-quota-process-pointer-overwrite" class="heading-mark"></a>3.5 Quota Process Pointer Overwrite</h3><p>配额进程指针覆写攻击（Quota Process Pointer Overwrite）</p>
<p>由于进程可能需要为分配的池内存填充(charged)，池分配必须提供足够的信息，以便池算法将收费配额返回给正确的进程。出于这个原因，池块可以选择性地存储与之关联的进程对象的指针。在x64上，进程对象指针存储在池头的最后八个字节中，如第2.9节所述；而在x86上，该指针附加到池体中。在池损坏漏洞中覆写这个指针（图7）可能允许攻击者释放正在使用的进程对象或在返回收费配额时破坏任意内存。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143057410.png" style="--width: 1120px;--aspect-ratio: 1120 / 282;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>每当释放一个池分配时，释放算法会在实际将内存返回给适当的空闲列表或<code>lookaside</code>之前，检查池类型的配额位（quota,0x8）。如果该位被设置，它将尝试通过调用<code>nt!PspReturnQuota</code>来返回收取的配额，然后对关联的进程对象进行解引用。因此，覆写进程对象指针可能允许攻击者减少任意进程对象的引用（指针）计数。如果满足正确的条件（例如当引用计数降低到零时句柄计数为零），引用计数不一致可能随后导致use-after-frees问题。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816143126611.png" style="--width: 1075px;--aspect-ratio: 1075 / 442;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>如果将进程对象指针替换为指向用户模式内存的指针，攻击者可以创建一个伪造的<code>EPROCESS</code>对象来控制指向<code>EPROCESS_QUOTA_BLOCK</code>结构（图8）的指针，该结构存储了配额信息。在释放时，通过减去分配的大小，更新了该结构中表示配额使用的值。因此，攻击者可以在返回收费配额时减少任意地址的值。只要配额位和配额进程对象指针都被设置，攻击者可以对任何池分配进行这两种攻击。</p>
<h2 id="4case-study-cve-2010-1893" class="heading-element">
  <a href="#4case-study-cve-2010-1893" class="heading-mark"></a>4.Case Study: CVE-2010-1893</h2><p>在本节中，我们将在Windows TCP/IP内核模块中利用池溢出（CVE-2010-1893）中描述的<code>PoolIndex</code>覆写技术，该漏洞已在MS10-058 [10]中得到修复。所描述的攻击仅操作池管理结构，因此不依赖于涉及的任何池块中保存的数据。</p>
<h3 id="41-about-the-vulnerability" class="heading-element">
  <a href="#41-about-the-vulnerability" class="heading-mark"></a>4.1 About the Vulnerability</h3><p>Windows TCP/IP内核模块（<code>tcpip.sys</code>）实现了多个用于控制套接字模式的函数。大部分情况下，用户可以通过调用<code>WSAIoctl</code>并提供所需操作的I/O控制代码来访问这些函数。在指定<code>SIO_ADDRESS_LIST_SORT</code> ioctl时，<code>tcpip.sys</code>调用<code>IppSortDestinationAddresses()</code>函数对IPv6和IPv4目标地址列表进行排序，以确定用于建立连接的最佳可用地址。然而，这个函数在Windows 7/Windows 2008 R2和Windows Vista/Windows 2008上存在整数溢出漏洞 [17]，因为它没有始终使用安全的整数函数。因此，为地址列表指定大量地址可能导致分配的缓冲区过小，从而在<code>IppFlattenAddressList()</code>中导致池溢出。</p>
<p>该漏洞实质上允许攻击者使用任意字节的组合来破坏相邻的池内存，池内存的大小为<code>SOCKADDR_IN6</code>记录（0x1c字节）。内存复制在<code>sin6_family</code>结构体成员不再等于0x17（<code>AF_INET6</code>）时停止。然而，由于此检查是在复制完成后进行的，因此当仅溢出单个地址记录时，攻击者无需设置该字段。换句话说，攻击者可以通过溢出单个地址记录来破坏相邻的池内存，而无需设置<code>sin6_family</code>字段。</p>
<h3 id="42-preparing-pool-memory" class="heading-element">
  <a href="#42-preparing-pool-memory" class="heading-mark"></a>4.2 Preparing Pool Memory</h3><p>内核池利用的一个重要方面是能够始终覆写所需的内存。由于内核池的碎片化状态使得分配的局部性不可预测，攻击者必须首先使用内核对象或其他可控内存分配来对内核池进行碎片整理。在这方面的目标是分配所有的空闲块，以便池分配器返回一个新的页面。将新分配的页面填充相同大小的分配并释放每个第二个分配，允许攻击者为易受攻击的缓冲区创建空洞。这反过来将使攻击者能够溢出用于填充内核池的对象或内存分配。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144524537.png" style="--width: 1130px;--aspect-ratio: 1130 / 696;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>在示例3中，内核池已被填充了<code>IoCompletionReserve</code>对象（使用<code>NtAllocateReserveObject</code> [7]），其中每隔一个分配后来被释放。因此，当在<code>IppSortDestinationAddresses()</code>函数中分配一个与已释放块的大小（三个<code>SOCKADDR_IN6</code>条目）相匹配的地址排序缓冲区时，很有可能它会掉入其中一个创建的空洞(holes)中。</p>
<h3 id="43-using-poolindex-overwrite" class="heading-element">
  <a href="#43-using-poolindex-overwrite" class="heading-mark"></a>4.3 Using PoolIndex Overwrite</h3><p>为了利用<code>PoolIndex</code>攻击，攻击者必须溢出以下池块的池头，并将其<code>PoolType</code>设置为<code>PagedPool|InUse(3)</code>，将其<code>PoolIndex</code>设置为越界索引（例如，在大多数单处理器系统上为5），如示例4所示。这将导致在释放被破坏的池块时引用空指针池描述符。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816144835052.png" style="--width: 1141px;--aspect-ratio: 1141 / 511;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>在代码清单1(下面)的函数中，我们初始化了进行攻击所需的池描述符值。在这个函数中，<code>PoolAddress</code>指向一个用户可控的池块（例如，在用户模式页面上分配的），而<code>WriteAddress</code>则设置了<code>PoolAddress</code>指针被写入的地址。</p>
<div class="highlight" id="id-12"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">VOID</span>
</span></span><span class="line"><span class="cl"><span class="nf">InitPoolDescriptor</span><span class="p">(</span><span class="n">PPOOL_DESCRIPTOR</span> <span class="n">PoolDescriptor</span><span class="p">,</span> <span class="n">PPOOL_HEADER</span> <span class="n">PoolAddress</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">WriteAddress</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ULONG</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RtlZeroMemory</span><span class="p">(</span><span class="n">PoolDescriptor</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">POOL_DESCRIPTOR</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">PoolType</span> <span class="o">=</span> <span class="n">PagedPool</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">PagedLock</span><span class="p">.</span><span class="n">Count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// create pending frees list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">PendingFreeDepth</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">PendingFrees</span> <span class="o">=</span> <span class="p">(</span><span class="n">VOID</span> <span class="o">**</span><span class="p">)(</span><span class="n">PoolAddress</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// create ListHeads entries with target address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">ListHeads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flink</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">WriteAddress</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">PoolDescriptor</span><span class="o">-&gt;</span><span class="n">ListHeads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Blink</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">WriteAddress</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>我们假设使用待释放列表(pending frees list)，因为大多数系统具有512MB或更多的RAM。因此，在链接过程中，用户可控池块的地址最终将被写入到WriteAddress指示的地址中。这可以用来覆写内核函数指针，使得利用变得简单。如果不使用待释放列表，已释放的内核池块的地址（内核地址）将被写入到指定的地址中，这种情况下需要使用其他手段，如部分指针覆写来执行任意代码。</p>
<p>在触发溢出之前的最后一个任务是初始化由<code>PoolAddress</code>指向的内存，以便将伪造的池块（在待释放列表中）正确返回到精心构造的<code>ListHeads</code>列表中（触发任意写入）。在代码清单2(下面)的函数中，我们创建了两个相邻的池块的布局，其中<code>PoolIndex</code>再次引用了与相关池描述符数组的越界索引。此外，<code>BlockSize</code>必须足够大，以避免使用<code>lookaside</code>列表。</p>
<div class="highlight" id="id-13"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">##define BASE_POOL_TYPE_MASK 1
</span></span></span><span class="line"><span class="cl"><span class="cp">##define POOL_IN_USE_MASK 2
</span></span></span><span class="line"><span class="cl"><span class="cp">##define BLOCK_SHIFT 3 </span><span class="c1">// 4 on x64
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">VOID</span> <span class="nf">InitPoolChunks</span><span class="p">(</span><span class="n">PVOID</span> <span class="n">PoolAddress</span><span class="p">,</span> <span class="n">USHORT</span> <span class="n">BlockSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">POOL_HEADER</span> <span class="o">*</span><span class="n">pool</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SLIST_ENTRY</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// chunk to be freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">POOL_HEADER</span> <span class="o">*</span><span class="p">)</span><span class="n">PoolAddress</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PreviousSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PoolIndex</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// out - of - bounds pool index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">=</span> <span class="n">BlockSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PoolType</span> <span class="o">=</span> <span class="n">POOL_IN_USE_MASK</span> <span class="o">|</span> <span class="p">(</span><span class="n">PagedPool</span> <span class="o">&amp;</span> <span class="n">BASE_POOL_TYPE_MASK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// last chunk on the pending frees list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">SLIST_ENTRY</span> <span class="o">*</span><span class="p">)((</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">PoolAddress</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">POOL_HEADER</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// bordering chunk ( busy to avoid coalescing )
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pool</span> <span class="o">=</span> <span class="p">(</span><span class="n">POOL_HEADER</span> <span class="o">*</span><span class="p">)((</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">PoolAddress</span> <span class="o">+</span> <span class="p">(</span><span class="n">BlockSize</span> <span class="o">&lt;&lt;</span> <span class="n">BLOCK_SHIFT</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PreviousSize</span> <span class="o">=</span> <span class="n">BlockSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PoolIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">BlockSize</span> <span class="o">=</span> <span class="n">BlockSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pool</span><span class="o">-&gt;</span><span class="n">PoolType</span> <span class="o">=</span> <span class="n">POOL_IN_USE_MASK</span> <span class="o">|</span> <span class="p">(</span><span class="n">PagedPool</span> <span class="o">&amp;</span> <span class="n">BASE_POOL_TYPE_MASK</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><h2 id="5kernel-pool-hardening" class="heading-element">
  <a href="#5kernel-pool-hardening" class="heading-mark"></a>5.Kernel Pool Hardening</h2><p>尽管引入了safe unlinking是朝着正确方向迈出的一步，但就与用户空间堆的健壮性相匹配而言，内核池利用的预防仍有很长的路要走。在本节中，我们提出了解决第3节中讨论的攻击的方法，以及关于如何进一步改进内核池的建议。</p>
<h3 id="51-listentry-flink-overwrite" class="heading-element">
  <a href="#51-listentry-flink-overwrite" class="heading-mark"></a>5.1 ListEntry Flink Overwrite</h3><p>safe unlinking被引入到内核池中，以防止池溢出的通用利用。然而，正如第3.1节所示，不充分的验证可能会在从空闲列表（<code>ListHeads</code>）分配条目时允许攻击者破坏任意内存。正如之前指出的那样，这是由于安全解链未在实际解链的块上执行，而是在目标<code>ListHeads</code>数组条目的<code>LIST_ENTRY</code>结构上执行。因此，一个简单的修复方法是正确验证被解链的块的前向和后向链接。</p>
<p>在对已经高度优化的池管理算法引入额外的缓解措施时，一个主要关注的问题是这些改变是否会对性能产生显著影响[3]。最大的关注点不是引入的额外指令数量，而是改变是否需要额外的分页操作，这在性能方面非常昂贵。解决第3.1节中的攻击可能会对性能产生影响，因为解链的块的前向链接的地址不能保证被分页到内存中，因此在安全解链时可能会触发页面错误（page-fault）。</p>
<h3 id="52-lookaside-next-pointer-overwrite" class="heading-element">
  <a href="#52-lookaside-next-pointer-overwrite" class="heading-mark"></a>5.2 Lookaside Next Pointer Overwrite</h3><p>由于<code>lookaside</code>列表本质上是不安全的，要解决它们的缺点而又不对内核池进行重大改变显然是一项具有挑战性的任务。在Vista和Windows 7堆中，为了取而代之，<code>lookaside</code>列表已被移除，采用了低碎片堆（low fragmentation heap）[9]。低碎片堆避免了使用嵌入指针，并大大降低了攻击者准确操纵堆的能力。因此，类似的方法可以在内核中使用。然而，移除高度优化的看aside列表可能会在一定程度上影响性能。</p>
<p><img loading="lazy" src="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png" alt="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png" srcset="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png?size=small, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png?size=medium 1.5x, /posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png?size=large 2x" data-title="/posts/2023-8-kernelpoolexploitationonwin7/image-20230816145649040.png" style="--width: 1008px;--aspect-ratio: 1008 / 561;background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></p>
<p>或者，可以添加池块完整性检查来帮助防止对lookaside列表指针的利用。由于所有池块都必须为<code>LIST_ENTRY</code>结构保留空间，而<code>lookaside</code>指针只需要一半的大小（<code>SLIST_ENTRY</code>），所以在<code>lookaside</code>列表上的池块可以在Next指针之前存储一个4字节（或x64上的8字节）的cookie（图9）。这个cookie应该对用户模式来说是非平凡的，并且可以是一个随机值（例如由<code>lookaside</code>列表结构或处理器控制块定义）与块的地址进行异或运算得到的。然而，请注意，这并不一定能够防止在攻击者可以写入已分配块的选择偏移量的情况下进行利用（例如数组索引漏洞）。</p>
<h3 id="53-pendingfrees-next-pointer-overwrite" class="heading-element">
  <a href="#53-pendingfrees-next-pointer-overwrite" class="heading-mark"></a>5.3 PendingFrees Next Pointer Overwrite</h3><p>由于<code>PendingFrees</code>列表是单链表，它们显然存在与前面提到的<code>lookaside</code>列表相同的问题。因此，为了防止池溢出的利用，<code>PendingFrees</code>列表也可以受益于嵌入式池块cookie。虽然可以使用双链表，但这将需要在<code>ExFreePoolWithTag</code>中进行额外的锁定（在插入条目到列表时），这将带来计算开销，并且会破坏延迟释放列表的目的。</p>
<h3 id="54-poolindex-overwrite" class="heading-element">
  <a href="#54-poolindex-overwrite" class="heading-mark"></a>5.4 PoolIndex Overwrite</h3><p>由于<code>PoolIndex</code>被用作池描述符数组的索引，正确的方式是在释放块之前根据数组的总条目数验证其值。这样可以防止攻击者引用越界的数组索引并控制池描述符。如第4节所示，可以通过在链接之前对相邻的块进行验证来防止<code>PoolIndex</code>的覆写。</p>
<p>请注意，这种技术也是对空指针的滥用的另一个明显案例。因此，不仅可以解决这种特定的攻击，还可以解决许多其他可利用的空指针内核漏洞，将虚拟地址空（0）在非系统进程中禁止映射可能是一个解决方案。目前，空页面主要用于向后兼容，例如Virtual Dos Machine（VDM）用于在WOW应用程序中寻址16位内存。因此，攻击者可以通过注入到WOW进程中来绕过空页面映射限制。</p>
<h3 id="55-quota-process-pointer-overwrite" class="heading-element">
  <a href="#55-quota-process-pointer-overwrite" class="heading-mark"></a>5.5 Quota Process Pointer Overwrite</h3><p>在第3.5节中，我们展示了攻击者如何利用池破坏漏洞来取消引用任意进程对象指针。这在x64系统上特别容易实现，因为该指针存储在池头中，而不是像x86系统那样存储在池块的末尾。为了防止利用使用该指针的漏洞，可以使用简单的编码（使用攻击者不知道的常量）来混淆其实际值。然而，这种方法的一个明显问题是，池破坏可能会更难调试，因为解码不正确的指针可能会引用与崩溃无关的数据。尽管如此，仍然可以进行某些检查来验证解码后的指针，例如确保它具有正确的对齐方式并且在预期范围内。</p>
<h2 id="6conclusion" class="heading-element">
  <a href="#6conclusion" class="heading-mark"></a>6.Conclusion</h2><p>在本文中，我们展示了尽管进行了安全的解链操作，但Windows 7内核池仍然容易受到通用攻击。然而，大多数已识别的攻击向量可以通过添加简单的检查或采用用户空间堆的防攻击功能来解决。因此，在未来的Windows版本和服务包中，我们很可能会看到内核池的额外加固措施。特别是，内核池将受益于池头部的校验和或Cookie，以防止涉及池头部破坏或恶意池构造的利用。</p>
<h2 id="references" class="heading-element">
  <a href="#references" class="heading-mark"></a>References</h2><p>[1] Alexander Anisimov: Defeating Microsoft Windows XP SP2 Heap Protection and DEP Bypass. <a href="http://www.ptsecurity.com/download/defeating-xpsp2-heap-protection.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://www.ptsecurity.com/download/defeating-xpsp2-heap-protection.pdf</a>
[2] Adam Barth, Collin Jackson, Charles Reis: The Security Architecture of the Chromium Browser. <a href="http://crypto.stanford.edu/websec/chromium/chromium-security-architecture.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://crypto.stanford.edu/websec/chromium/chromium-security-architecture.pdf</a></p>
<p>[3] Pete Beck: Safe Unlinking in the Kernel Pool. Microsoft Security Research and Defense. <a href="http://blogs.technet.com/srd/archive/2009/05/26/safe-unlinking-in-the-kernel-pool.aspx"target="_blank" rel="external nofollow noopener noreferrer">http://blogs.technet.com/srd/archive/2009/05/26/safe-unlinking-in-the-kernel-pool.aspx</a></p>
<p>[4] Dion Blazakis: Interpreter Exploitation: Pointer Inference and JIT Spraying. Black Hat DC 2010. <a href="http://www.semantiscope.com/research/BHDC2010"target="_blank" rel="external nofollow noopener noreferrer">http://www.semantiscope.com/research/BHDC2010</a></p>
<p>[5] Matt Conover &amp; Oded Horovitz: Windows Heap Exploitation. CanSecWest 2004.</p>
<p>[6] Matthew Jurczyk: Windows Objects in Kernel Vulnerability Exploitation. Hack-in-the-Box Magazine 002. <a href="http://www.hackinthebox.org/misc/HITB-Ezine-Issue-002.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://www.hackinthebox.org/misc/HITB-Ezine-Issue-002.pdf</a></p>
<p>[7] Matthew Jurczyk: Reserve Objects in Windows 7. Hack-in-the-Box Magazine 003. <a href="http://www.hackinthebox.org/misc/HITB-Ezine-Issue-003.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://www.hackinthebox.org/misc/HITB-Ezine-Issue-003.pdf</a></p>
<p>[8] Kostya Kortchinsky: Real World Kernel Pool Exploitation. SyScan 2008. <a href="http://www.immunitysec.com/downloads/KernelPool.odp"target="_blank" rel="external nofollow noopener noreferrer">http://www.immunitysec.com/downloads/KernelPool.odp</a></p>
<p>[9] Adrian Marinescu: Windows Vista Heap Management Enhancements. Black Hat USA 2006. <a href="http://www.blackhat.com/presentations/bh-usa-06/BH-US-06-Marinescu.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://www.blackhat.com/presentations/bh-usa-06/BH-US-06-Marinescu.pdf</a></p>
<p>[10] Microsoft Security Bulletin MS10-058: Vulnerabilities in TCP/IP Could Allow Elevation of Privilege. <a href="http://www.microsoft.com/technet/security/Bulletin/MS10-058.mspx"target="_blank" rel="external nofollow noopener noreferrer">http://www.microsoft.com/technet/security/Bulletin/MS10-058.mspx</a></p>
<p>[11] mxatone: Analyzing Local Privilege Escalation in win32k. Uninformed Journal, vol. 10, article 2. <a href="http://www.uninformed.org/?v=10&amp;a=2"target="_blank" rel="external nofollow noopener noreferrer">http://www.uninformed.org/?v=10&a=2</a></p>
<p>[12] Office Team: Protected View in Office 2010. Microsoft Office 2010 Engineering. <a href="http://blogs.technet.com/b/office2010/archive/2009/08/13/protected-view-in-office-2010.aspx"target="_blank" rel="external nofollow noopener noreferrer">http://blogs.technet.com/b/office2010/archive/2009/08/13/protected-view-in-office-2010.aspx</a></p>
<p>[13] Kyle Randolph: Inside Adobe Reader Protected Mode - Part 1 - Design. Adobe Secure Software Engineering Team (ASSET) Blog. <a href="http://blogs.adobe.com/asset/2010/10/inside-adobe-reader-protected-mode-part-1-design.html"target="_blank" rel="external nofollow noopener noreferrer">http://blogs.adobe.com/asset/2010/10/inside-adobe-reader-protected-mode-part-1-design.html</a></p>
<p>[14] Ruben Santamarta: Exploiting Common Flaws in Drivers. <a href="http://reversemode.com/index.php?option=com_remository&amp;Itemid=2&amp;func=fileinfo&amp;id=51"target="_blank" rel="external nofollow noopener noreferrer">http://reversemode.com/index.php?option=com_remository&Itemid=2&func=fileinfo&id=51</a></p>
<p>[15] Hovav Shacham: The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86). In Proceedings of CCS 2007, pages 552561.ACM Press, Oct. 2007.</p>
<p>[16] SoBeIt: How To Exploit Windows Kernel Memory Pool. Xcon 2005. <a href="http://packetstormsecurity.nl/Xcon2005/Xcon2005_SoBeIt.pdf"target="_blank" rel="external nofollow noopener noreferrer">http://packetstormsecurity.nl/Xcon2005/Xcon2005_SoBeIt.pdf</a></p>
<p>[17] Matthieu Suiche: Microsoft Security Bulletin (August). <a href="http://moonsols.com/blog/14-august-security-bulletin"target="_blank" rel="external nofollow noopener noreferrer">http://moonsols.com/blog/14-august-security-bulletin</a></p>
</div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="更新于 2023-08-16 00:00:00">更新于 2023-08-16&nbsp;</span>
      </div><div class="post-info-license">
            <span><a rel="license external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span>
          </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/" data-title="【译】Kernel Pool Exploitation on Windows 7" data-hashtags="Windows"><i class="fa-brands fa-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/" data-hashtag="Windows"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://ghostasky.github.io/posts/2023-8-kernelpoolexploitationonwin7/" data-title="【译】Kernel Pool Exploitation on Windows 7"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/windows/" class="post-tag" title="标签 - Windows">Windows</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/2023-8-hevd/" class="post-nav-item" rel="prev" title="HEVD-Windows7x86 SP1 记录"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>HEVD-Windows7x86 SP1 记录</a>
      <a href="/posts/2023-8-scoopthewindows10pool/" class="post-nav-item" rel="next" title="【译】Scoop The Windows 10 Pool">【译】Scoop The Windows 10 Pool<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="目录"><h2 class="toc-title">目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
    <div class="footer-container"><div class="footer-line powered">由 <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.123.8"><img class="hugo-icon" src="/images/hugo.min.svg" alt="Hugo logo" /> Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.2"><img class="fixit-icon" src="/images/fixit.min.svg" alt="FixIt logo" /> FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">
              <a href="/"></a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="回到顶部"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><noscript>
    <div class="noscript-warning">FixIt 主题在启用 JavaScript 的情况下效果最佳。</div>
  </noscript>
</div><link rel="preload" href="/lib/katex/katex.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="stylesheet" href="/lib/cookieconsent/cookieconsent.min.css"><script src="/lib/sharer/sharer.min.js" async defer></script><script src="/lib/katex/katex.min.js" defer></script><script src="/lib/katex/auto-render.min.js" defer></script><script src="/lib/katex/copy-tex.min.js" defer></script><script src="/lib/katex/mhchem.min.js" defer></script><script src="/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"复制到剪贴板","editLockTitle":"锁定可编辑代码块","editUnLockTitle":"解锁可编辑代码块","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"同意","link":"了解更多","message":"本网站使用 Cookies 来改善您的浏览体验。"},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script src="/js/theme.min.js" defer></script></body>
</html>
